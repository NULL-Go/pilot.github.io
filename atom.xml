<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://null-go.github.io</id>
    <title>PILOT</title>
    <updated>2021-04-07T08:05:09.880Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://null-go.github.io"/>
    <link rel="self" href="https://null-go.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://null-go.github.io/images/avatar.png</logo>
    <icon>https://null-go.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, PILOT</rights>
    <entry>
        <title type="html"><![CDATA[【CSS3】基础]]></title>
        <id>https://null-go.github.io/post/css3-ji-chu/</id>
        <link href="https://null-go.github.io/post/css3-ji-chu/">
        </link>
        <updated>2021-03-25T11:32:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="border-radius">border-radius</h1>
<p>单位：可以是 em rem vw等相对单位，还可以是百分比，相当于宽高。<br>
多值：4个 左上角开始顺时针 3个 左上-&gt;对角线-&gt;右下 2个 左上右下-&gt;右上左下<br>
拆分复合属性：左上 border-top/bottom-left/right-radius</p>
<h1 id="box-shadow">box-shadow</h1>
<p>语法：box-shadow: h-shadow v-shadow blur/模糊距离 spread/阴影大小 color inset;<br>
blur：意思是从外到里经过多远变得不模糊<br>
spread：阴影会向四周扩大的大小<br>
inset：当设置为inset属性时，阴影变为内侧阴影</p>
<pre><code>{
    box-shadow:20px 20px 20px 0px red inset
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://null-go.github.io/post-images/1616678037534.png" alt="" loading="lazy"></figure>
<h1 id="border-image">border-image</h1>
<p>没看懂暂时</p>
<h1 id="background-属性">background-*属性</h1>
<p>语法：<br>
background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p>
<h2 id="background-img">background-img</h2>
<p>语法：background-img:url(&quot;&quot;);</p>
<h2 id="background-repeat">background-repeat</h2>
<p>设置背景图片的平铺 默认值repeat x,y轴平铺，repeat-x repeat-y no-repeat</p>
<h2 id="background-clip-背景裁剪显示的区域">background-clip 背景裁剪显示的区域</h2>
<p>值：border-box 默认 padding-box content-box</p>
<h2 id="background-position-背景图像的起始位置">background-position 背景图像的起始位置</h2>
<p>值：第一个值是水平位置 第二个值是垂直位置<br>
水平位置用left right center ，垂直位置用top center bottom，只写一个另外一个为center<br>
百分比 0% 0%，代表是left top 左上角也可以用，只写一个另外一个为50%<br>
x pos y pos，离起点的偏移量，只写一个另外一个为50%</p>
<h2 id="background-orgin-指定background-position属性应该是相对位置">background-orgin 指定background-position属性应该是相对位置</h2>
<p>值：padding-box 默认 border-box content-box</p>
<h1 id="渐变">渐变</h1>
<h2 id="线性渐变-沿着一根轴线改变颜色从一边拉向另一边">线性渐变 沿着一根轴线改变颜色(从一边拉向另一边)</h2>
<p><strong>语法一</strong>：linear-gradients(direction, color-stop1, color-stop2, ...);<br>
默认不写direction为从上到下 direction分兼容性<br>
若为 -webkit-内核 direction为开始方向，其他 内核 direction为结束方向<br>
若不写兼容性，direction 标准为 to direction<br>
<strong>语法二</strong>：linear-gradients(angle deg, color-stop1, color-stop2, ...);<br>
<img src="https://null-go.github.io/post-images/1616916263966.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【CSS】布局]]></title>
        <id>https://null-go.github.io/post/css-bu-ju/</id>
        <link href="https://null-go.github.io/post/css-bu-ju/">
        </link>
        <updated>2021-03-24T10:38:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="定位方案">定位方案</h1>
<ul>
<li>普通流(normal flow)     在普通文档流中的盒子属于一种<strong>格式化上下文</strong>（Formatting Context），常见的两种特殊的格式化上下文就是块格式化上下文（Block formatting context）和行内格式化上下文（Inline formatting context）。<br>
破坏性属性 👇 即破坏普通流</li>
<li>浮动(float) **脱离普通流。**在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移;  float属性最初只用于在成块的文本内浮动图像，文字环绕在它的左边或右边文本会环绕在它的周围，所以文本会环绕在浮动元素旁边。</li>
<li>绝对定位 absolute 或fixed(absolute positioning) <strong>脱离普通流。</strong><br>
https://www.cnblogs.com/chaixiaozhi/p/8481253.html</li>
</ul>
<h2 id="bfc">BFC</h2>
<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<h1 id="bfc特性">BFC特性：</h1>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠(BFC导致<strong>外边距折叠</strong>)</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此(BFC导致浮动元素可能遮盖其他元素，文本不会被遮盖，文本会环绕浮动元素)</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素(一种自适应特性)。反之也如此。(当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。)</li>
<li>计算BFC的高度时，浮动元素也参与计算(用来清除浮动)</li>
</ul>
<h1 id="产生bfc满足下列条件中的一个">产生BFC(满足下列条件中的一个)：</h1>
<ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ul>
<h1 id="bfc的作用">BFC的作用：</h1>
<ul>
<li>自适应两栏布局，aside栏设置float：left，固定宽高，main栏设置高度，不设定宽度，main一部分会被浮动元素遮盖(即使文字不会)，将main元素设置为BFC元素，利用BFC特性：BFC的区域不会与float box重叠，可以实现main区域自适应宽度</li>
<li>取消外边距折叠</li>
<li>清除浮动</li>
</ul>
<h1 id="浮动">浮动</h1>
<h2 id="工作原理浮动元素会脱离正常的文档布局流并吸附到其父容器的左边floatleft-在正常布局中位于该浮动元素之下的内容此时会围绕着浮动元素填满其右侧的空间">工作原理：浮动元素会脱离正常的文档布局流，并吸附到其父容器的左边(float:left)。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</h2>
<p>浮动元素表现的像inline-block一样</p>
<h2 id="清除浮动">清除浮动</h2>
<p>float会将元素变成内联块级元素<br>
float 父元素高度塌陷 清除浮动<br>
https://cssgridgarden.com/#zh-cn</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】DOM]]></title>
        <id>https://null-go.github.io/post/js-dom/</id>
        <link href="https://null-go.github.io/post/js-dom/">
        </link>
        <updated>2021-03-18T12:20:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="dom">DOM</h1>
<p>文档对象模型（Document Object Model）</p>
<p>document 对象是页面的主要入口点</p>
<h1 id="dom树"><strong>DOM树</strong></h1>
<p>每个HTML标签都是一个对象，标签内的文本也是一个对象。</p>
<p>标签称为元素节点，元素内的文本形成文本节点(一个文本节点只包含一个字符串，它总是叶子节点)</p>
<p><strong>空格和换行符</strong>都是完全有效的字符，它们可以形成文本节点。</p>
<blockquote>
<p>表格是一个有趣的“特殊的例子”。按照 DOM 规范，它们必须具有 &lt; tbody &gt;，但 HTML 文本却（官方的）忽略了它。然后浏览器在创建 DOM 时，自动地创建了 &lt; tbody &gt;。</p>
</blockquote>
<p>html 标签 document.documentElement</p>
<p>body 标签 document.body</p>
<p>head 标签 document.head</p>
<blockquote>
<p>在控制台中选中元素，且对其进行操作</p>
</blockquote>
<p>先选元素 然后按ESC $0是最后一次选择的元素 $1是前一个选择的元素</p>
<h2 id="查找"><strong>查找</strong></h2>
<p><strong>子节点</strong> 一层</p>
<p><strong>子孙节点</strong> 多层</p>
<p><strong>childNodes</strong>属性 集合列出了所有子节点，包括文本节点。</p>
<p><strong>首尾子节点</strong></p>
<p>如果元素存在子节点的 childNodes[0]==firstChild</p>
<p>​                               childNodes[childNodes.length - 1]==lastChild</p>
<p><strong>兄弟节点</strong>nextSibling previousSibling</p>
<p><strong>父节点</strong>parentNode</p>
<p>把这些属性加上Element关键词，即可忽略文本节点</p>
<ul>
<li>
<p>children — 仅那些作为元素节点的子代的节点</p>
</li>
<li>
<p>firstElementChild，lastElementChild — 第一个和最后一个子元素。</p>
</li>
<li>
<p>previousElementSibling，nextElementSibling — 兄弟元素。</p>
</li>
<li>
<p>parentElement — 父元素。</p>
</li>
</ul>
<p>搜索DOM最常用的方法 document.querySelectorAll()和querySelector()</p>
<p>element.matches()方法 匹配给定的css选择器 返回true or false</p>
<p>element.closest()方法是matches方法的精简版，它只搜索它自己和它的祖先，返回值为第一个找到的元素</p>
<p><strong>querySelector类型的方法和getElementsBy*类型的方法的区别</strong></p>
<p>所有的 &quot;getElementsBy*&quot; 方法都会返回一个 实时的（live） 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。(getElementById 返回一个元素，所有没有实时集合这一说法)</p>
<p>相反，querySelector类型返回的内容固定不变。</p>
<h2 id="dom集合类数组的可迭代对象">DOM集合(类数组的可迭代对象)</h2>
<ol>
<li>
<p>可以用for of 迭代</p>
</li>
<li>
<p>有length属性和下标但没有数组方法</p>
</li>
</ol>
<h2 id="dom的继承关系">DOM的继承关系</h2>
<figure data-type="image" tabindex="1"><img src="https://null-go.github.io/post-images/1616076970054.png" alt="" loading="lazy"></figure>
<p><strong>nodeName</strong>属性适用于Node类 tagName适用于Element类。</p>
<p><strong>innerHTML</strong>属性使用于元素，允许将元素中的 HTML 获取为<strong>字符串形式</strong>。文本元素等其他元素用data或nodeValue。</p>
<p><strong>innerHTML</strong> innerHTML+= 会进行完全的重写 innerHTML = &quot;...&quot; + newHTML;这相当于整个HTML还是重新加载了，因此所有的图片和其他资源都将重写加载。</p>
<p><strong>outerHTML</strong> 属性包含了元素的完整 HTML。就像 innerHTML 加上元素本身一样。</p>
<p>outHTML 和 innerHTML最不一样的地方在于， oEle.outHTML = &quot;新的HTML内容&quot;; oEle元素并不会被修改，而是被替换，所有oEle对旧的HTML内容仍然可以引用，只是在DOM树中的位置被替换掉了。</p>
<p><strong>hidden</strong>属性，从技术上来说，hidden 与 style=&quot;display:none&quot; 做的是相同的事。</p>
<h1 id="dom特性attributes和属性properties">DOM特性(attributes)和属性(properties)</h1>
<p>当浏览器解析HTML，它会从中生成DOM对象。对于元素节点，标准的特性(attributes)会变成DOM对象的属性(properties)。故可以通过点 . 运算符获取属性。</p>
<p><strong>特性</strong> : 写在HTML中的内容</p>
<p><strong>属性</strong> : DOM元素对象的属性</p>
<p>所有特性(大小写不敏感)都可以通过使用以下方法进行访问：</p>
<ul>
<li>
<p>elem.hasAttribute(name) — 检查特性是否存在。</p>
</li>
<li>
<p>elem.getAttribute(name) — 获取这个特性值。</p>
</li>
<li>
<p>elem.setAttribute(name, value) — 设置这个特性值。</p>
</li>
<li>
<p>elem.removeAttribute(name) — 移除这个特性。</p>
</li>
<li>
<p>elem.attributes属性读取所有特性</p>
</li>
</ul>
<p>一般来说，一个标准的特性所对应的属性是关联改变的。</p>
<p>例外：  input 的value 属性</p>
<pre><code>// 特性 =&gt; 属性

  input.setAttribute('value', 'text');

  alert(input.value); // text



  // 这个操作无效，属性 =&gt; 特性

  input.value = 'newValue';

  alert(input.getAttribute('value')); // text（没有被更新！）

  //这个“功能”在实际中会派上用场，因为用户行为可能会导致 value 的更改，然后在这些操作之后，如果我们想从 HTML 中恢复“原始”值，那么该值就在特性中。
</code></pre>
<h2 id="非标准的特性"><strong>非标准的特性</strong></h2>
<p>非标准的特性常常用来设置元素的样式</p>
<pre><code>style : 

.order[order-state=&quot;new&quot;] {

    color: green;

}

dom :

&lt;div class=&quot;order&quot; order-state=&quot;new&quot;&gt;

  A new order.

&lt;/div&gt;

//特性值更容易管理。我们可以轻松地更改状态：

  div.setAttribute(&quot;order-state&quot;,new);
</code></pre>
<h1 id="修改文档"><strong>修改文档</strong></h1>
<h2 id="创建方法"><strong>创建方法</strong></h2>
<p>创建元素节点： let div = document.createElement(&quot;div&quot;);</p>
<p>创建文本节点： let textNode = document.createTextNode(&quot;Here is a text node&quot;) (即符号不会进行转义，原原本本的当做字符串显示)</p>
<h2 id="插入方法"><strong>插入方法</strong></h2>
<ul>
<li>
<p>node.append(...nodes or strings) 在node直接子元素最末尾插入</p>
</li>
<li>
<p>node.prepend(...nodes or strings) 在node直接子元素最开头插入</p>
</li>
<li>
<p>node.before(...nodes or strings) 在node前面插入</p>
</li>
<li>
<p>node.after(...nodes or strings) 在node后面插入</p>
</li>
<li>
<p>node.replaceWith(...nodes or strings) 替换node节点</p>
</li>
</ul>
<p>若插入的是字符串，文字将作为<strong>文本</strong>插入(不是HTML代码，即和node.innerHTML = &quot;&quot;不相同，和node.textContent相同)，自动将转化成<strong>文本节点</strong>，&lt;和&gt;等符号将会转义。所以这是一种更安全的方法插入文本，它并不会插入乱七八糟的元素。</p>
<h2 id="eleinsertadjacenthtmltextelementwherecontent">ele.insertAdjacentHTML/Text/Element(where,content)</h2>
<p><strong>where</strong> 参数的取值(4个):</p>
<p>beforebegin 元素之前 afterbegin 元素内部第一个子元素之前</p>
<p>beforeend 元素内部最后一个子元素之后 afterend 元素之后</p>
<p><strong>content</strong> 参数的取值:</p>
<p>对应传入即可，但是Text和Element均已有方法支持了。即append等。</p>
<h2 id="移除方法">移除方法</h2>
<p>node.remove()</p>
<p>注:<strong>如果我们要将一个元素移到另外一个位置，不需要进行remove，所有的插入方法都会从原来的位置删除</strong></p>
<h2 id="克隆节点">克隆节点</h2>
<p>node.cloneNode(true); <strong>深拷贝</strong> 会拷贝其本身(具有特性 attributes)及所有子节点</p>
<p>node.cloneNode(true); <strong>浅拷贝</strong> 只拷贝其本身(具有特性 attributes)</p>
<p>如何删除一个元素内的所有内容</p>
<pre><code>// 错误做法

        function clear(elem) {

            //     1

            for (let i = 0; i &lt; elem.childNodes.length; i++)

                elem.childNodes[i].remove;

            //     2

            for (let item of elem.childNodes)

                item.remove();



        }

        clear(elem); // 清除列表

        //  正确做法

        function clear(elem){

            while(elem.firstChild)

              elem.firstChild.remove();

        }

        clear(elem); // 清除列表
</code></pre>
<p>​</p>
<h1 id="样式和类"><strong>样式和类</strong></h1>
<h2 id="classname和classlist">className和classList</h2>
<p>对className赋值，将会替换整个字符串。</p>
<p>classList是一个特殊的<strong>对象</strong>(可迭代，类数组。classList[0])。它<strong>对应</strong>&quot;class&quot; attribute</p>
<p>classList有下列的方法：</p>
<ul>
<li>
<p>element.add/remove(className) 添加或移除单个类</p>
</li>
<li>
<p>element.toggle(className) 若类存在，则移除类，若类不存在，则添加类。</p>
</li>
<li>
<p>element.contains(className) 检查给定类，返回true/false</p>
</li>
</ul>
<h2 id="元素样式">元素样式</h2>
<p>elem.style 是一类特殊的对象。它<strong>对应</strong>&quot;style&quot; attribute</p>
<p><strong>因为它对应的是style这个attribute特性，所以只有内联的样式它才能够读取到，像是在style标签里定义的height，element.style.height得到是空字符串，通过赋值能改变样式的原因也是内联样式的优先级比较高</strong></p>
<p>对于多词（multi-word）属性，使用驼峰式 camelCase：</p>
<blockquote>
<p>background-color  =&gt; elem.style.backgroundColor</p>
</blockquote>
<p>浏览器前缀- 也用大写字母表示</p>
<pre><code>// 在单个语句中设置多个样式,相当于style attribute 内联样式对象被重置了
elt.style.cssText = &quot;color: blue; border: 1px solid black&quot;;
// 或者,也相当于style attribute 内联样式对象被重置了
elt.setAttribute(&quot;style&quot;, &quot;color:red; border: 1px solid blue;&quot;);

// 设置特定样式，同时保持其他内联样式值不变
elt.style.color = &quot;blue&quot;;
</code></pre>
<p>不能像这样的 div.style=&quot;color: red; width: 100px&quot; 设置完整的属性，因为 CSSStyleDeclaration <strong>应当</strong>是只读的（尽管它在Firefox，Chrome中都能被赋值，是对象本身整体只读，它的属性的值可以改变）。</p>
<pre><code>element.style = {}; 内联样式对象被清空了
getComputedSyle(element,null) = {}; 直接报错了
</code></pre>
<p>对于修改样式，我们可以通过elem.style.*=&quot;&quot; 修改内联样式的方法修改元素样式，如果想获取样式表中的样式，可以通过 getComputedStyle语法。</p>
<p>getComputed(element, [pseudo]) 需要完整的属性值，需要paddingLeft而不是padding</p>
<p>element：</p>
<p>需要被读取样式值的元素。</p>
<p>pseudo：</p>
<p>伪元素（如果需要），例如 ::before。空字符串或无参数则意味着元素本身。由于浏览器的兼容性问题，建议在选择元素本身时传入参数null。</p>
<p>同样返回一个具有样式属性的对象，像ele.style，但现在包括除内联外的其他样式了。</p>
<p><strong>Element.style 和 getComputedStyle(element,pseudo) 返回的均是一个 CSSStyleDeclaration对象</strong></p>
<p>*<em>注意 element.style.<em>和getComputedStyle() 方法返回的对象所拥有的属性均是字符串形式，所以用来参与运算时要特别注意</em></em></p>
<p>getComputedStyle 参与运算时单位要注意，这与下面说的几何属性不一致，几何属性均为<strong>数值</strong>且单位是px</p>
<figure data-type="image" tabindex="2"><img src="https://null-go.github.io/post-images/1616480743854.png" alt="" loading="lazy"></figure>
<h1 id="元素大小和滚动">元素大小和滚动</h1>
<h2 id="元素结构">元素结构</h2>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329102157711.png" alt="image-20210329102157711" style="zoom:80%;" />
<p>这里设置的width本来是300px，但是滚动条占据了一部分内容宽度。(不同的浏览器对滚动条的处理不同)</p>
<p>不包括margin，它本身不是元素的一部分。</p>
<h2 id="几何">几何</h2>
<h2 id="几何属性除-scrolltop和scrollleft外其他均只读">几何属性除 scrollTop和scrollLeft外，其他均只读</h2>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329102509892.png" alt="image-20210329102509892" style="zoom: 80%;" />
<p>这些属性值在技术上来讲是数字，实际上是“像素”，且仅在元素display不为none的情况下有属性值。</p>
<p><strong>offsetParent</strong>：属性，指向最接近的祖先，最近的祖先为下列之一：</p>
<ol>
<li>css定位的元素(position为absolute,relative,fixed)</li>
<li>或<code>&lt;td&gt;</code>,<code>&lt;th&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;body&gt;</code></li>
</ol>
<p><strong>offsetTop和offsetLeft</strong>：提供相对于祖先元素的偏移量，如图</p>
<p>有以下几种情况下，<strong>offsetParent</strong> 的值为 <code>null</code>：</p>
<ol>
<li>对于未显示的元素（<code>display:none</code> 或者不在文档中）。</li>
<li>对于 <code>&lt;body&gt;</code> 与 <code>&lt;html&gt;</code>。</li>
<li>对于带有 <code>position:fixed</code> 的元素。</li>
</ol>
<p><strong>offsetWidth/offsetHeight</strong></p>
<p>包括border及其以内的所有元素大小之和。</p>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329103659938.png" alt="image-20210329103659938" style="zoom:80%;" />
<p><strong>clientWidth/clientHeight</strong></p>
<p>border内(除border)大小，包括了 “content width” 和 “padding”，但不包括滚动条宽度（scrollbar）。</p>
<p>**注：**内联元素和没有CSS样式的元素此属性为0</p>
<p><strong>scrollWidth/scrollHeight</strong></p>
<p>测量方式就像 <code>clientWidth/clientHeight</code>，但它们还包括滚动出（隐藏）的部分：</p>
<p><strong>scrollTop/scrollLeft(可修改)</strong></p>
<p>元素的隐藏、滚动部分的 width/height。</p>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329105848961.png" alt="image-20210329105848961" style="zoom:80%;" />
<blockquote>
<p>tips： 当<img>标签没有 width/height时（通过style标签attribute 或 CSS样式），浏览器会假定width和height为0，只到图片加载完成。在第一次加载完成后，浏览器通常会缓存图片，第二次加载时可以得到width/height。要解决第一次加载width/height的问题可以通过添加style标签attribute 或 CSS样式中的width和height解决。</p>
</blockquote>
<h2 id="css属性中width-和-几何属性中clientwidth-的区别">CSS属性中width 和 几何属性中clientWidth 的区别</h2>
<p>即 getComputedStyle(element).width、element.style.width 与 element.clientWidth 的区别</p>
<ol>
<li>CSS属性中的width是以'px'结束的字符串形式，而clientWidth给出的是数值形式</li>
<li>getComputedStyle(element).width对内联元素使用是auto，clientWidth对内联使用是0</li>
<li>CSS属性中的width是根据box-sizing 决定的</li>
<li>CSS属性中的width在不同的浏览器中对scroll的处理可能不一致（一些浏览器从width中抽取部分给scroll），而clientWidth总是不包括滚动条的。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】对象、原型链]]></title>
        <id>https://null-go.github.io/post/js-dui-xiang-yuan-xing-lian/</id>
        <link href="https://null-go.github.io/post/js-dui-xiang-yuan-xing-lian/">
        </link>
        <updated>2021-03-16T08:05:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="属性类型">属性类型</h1>
<h2 id="数据属性">数据属性</h2>
<p>属性标志：<br>
value,writable,configurale,enumerable;<br>
得到属性标识符对象:Object.getOwnPropertyDescriptor(obj,propertyName) 继承的属性不行<br>
修改或创建属性:Object.defineProperty(obj, propertyName, descriptor) 在这种情况在descriptor对象中若有属性没有提供值，会默认为false<br>
同类型的方法还有 getOwnPropertyDescriptors 和 defineProperties<br>
<strong>克隆对象的一个更好的方法</strong><br>
<strong>writable</strong>  属性无法改变 除非Object.defineProperty重新赋值<br>
<strong>configurable</strong> 属性，不可配置的属性不能被删除<br>
不可配置性对 defineProperty 施加了一些限制：</p>
<ul>
<li>不能修改 configurable 标志。</li>
<li>不能修改 enumerable 标志。</li>
<li>不能将 writable: false 修改为 true（反过来则可以）。</li>
<li>不能修改访问者属性的 get/set（但是如果没有可以分配它们）。<br>
<strong>enumerable</strong> 是否可枚举 for in   Object.keys()等等</li>
</ul>
<h2 id="访问器属性">访问器属性</h2>
<p>本质上是获取和设置属性的方法，但是从外部看起来就和普通的属性一样。写在对象中:<br>
get 属性值(){}  set 属性值(){}<br>
访问器标志：<br>
get,set,enumerable,configurable 访问器属性值不能有value,writable</p>
<h1 id="创建对象">创建对象</h1>
<h2 id="工厂模式">工厂模式</h2>
<p>构造函数在new操作符作用后，默认返回的值是那个对象，但是工厂模式在函数内部创建了一个对象，并把这个对象返回了，这样修改了默认的返回值</p>
<h2 id="构造函数模式-检测对象类型-instanceof操作符">构造函数模式 检测对象类型 instanceof操作符</h2>
<h2 id="原型模式">原型模式</h2>
<p>原型<br>
hasOwnProperty in 检测属性是存在于原型对象还是实例  in是无论存在实例还是原型中，均返回true<br>
Object.keys()方法返回实例对象中可枚举的属性<br>
getOwnPropertyNames返回实例对象中的属性，无论其可不可枚举<br>
每创建一个函数，都会同时创建它的prototype对象，这个对象也会自动获得constructor属性<br>
原型的动态性 实例和原型之间的连接仅仅是指针而已<br>
<strong>实例中的【【ProtoType】】指针指向原型而不是指向构造函数</strong></p>
<h2 id="组合使用构造函数模式和原型模式">组合使用构造函数模式和原型模式</h2>
<h2 id="动态原型模式">动态原型模式</h2>
<h2 id="寄生构造函数模式">寄生构造函数模式</h2>
<h2 id="稳妥构造函数模式">稳妥构造函数模式</h2>
<p>稳妥对象，指的是没有公共属性，并且方法中没有引用this<br>
利用闭包访问自己的属性</p>
<h1 id="对象与原型">对象与原型</h1>
<h2 id="对象的隐藏prototype属性-注不要和构造函数的-prototype-属性混淆">对象的隐藏[[Prototype]]属性 (注：不要和构造函数的 prototype 属性混淆)</h2>
<p>在 JavaScript 中，所有的对象都有一个隐藏的 [[Prototype]] 属性，它要么是另一个对象，要么就是 null。它👉的是该对象的原型。</p>
<ul>
<li>我们可以使用 obj.<strong>proto</strong> 访问它（历史遗留下来的 <strong>getter/setter</strong>)<br>
ES6中的访问接口: <em>Object.getProtoypeOf()</em> 和 <em>Object.setPrototype</em> 来get/set</li>
<li>如果我们想要读取 obj 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li>
<li>写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</li>
<li>如果我们调用 obj.method()，而且 method 是从原型中获取的，this 仍然会引用 obj。因此，方法始终与当前对象一起使用，即使方法是继承的。</li>
<li>请记住函数也是一个对象，它也有自己的原型。<pre><code>function f (){
}
console.log(f.prototype === Function.prototype); //flase
console.log(f.__proto__ === Function.prototype); //true
console.log(Function.__proto__ === Function.prototype); //true
</code></pre>
</li>
</ul>
<h2 id="构造函数">构造函数</h2>
<ul>
<li>每个函数都有 &quot;prototype&quot; 属性，即使我们没有提供它。默认的 &quot;prototype&quot; 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。</li>
<li>如果我们将整个默认 prototype 替换掉，那么其中就不会有 &quot;constructor&quot; 了</li>
<li>F.prototype 属性（不要把它与 [[Prototype]] 弄混了）在 new F 被调用时为新对象的 [*[Prototype]] 赋值。</li>
<li>F.prototype 的值要么是一个对象，要么就是 null：其他值都不起作用。</li>
<li>&quot;prototype&quot; 属性仅在设置了一个构造函数（constructor function），并通过 new 调用时，才具有这种特殊的影响。</li>
</ul>
<p>今天在看原型内容的时候遇到了一个问题：</p>
<pre><code>let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// 这只仓鼠找到了食物
speedy.eat(&quot;apple&quot;);
alert( speedy.stomach ); // apple

// 这只仓鼠也找到了食物，为什么？请修复它。
alert( lazy.stomach ); // apple
</code></pre>
<pre><code>let hamster = {
  stomach: [],

  eat(food) {
    // 分配给 this.stomach 而不是 this.stomach.push
    this.stomach = [food];
  }
};

let speedy = {
   __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// 仓鼠 Speedy 找到了食物
speedy.eat(&quot;apple&quot;);
alert( speedy.stomach ); // apple

// 仓鼠 Lazy 的胃是空的
alert( lazy.stomach ); // &lt;nothing&gt;
</code></pre>
<p>当对变量使用赋值操作和变量push操作的不同，让我想到了在小黄书中看到的LHS和RHS 左查询和右查询，右查询和对普通变量的值的查找没什么区别，而右查询是<strong>试图找到变量容器的本身并对其赋值</strong>。<br>
为什么push 和 = 的操作会造成不一样的影响，我思考后觉得 push操作仅仅是RHS，=操作是左赋值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】类数组对象和可迭代对象]]></title>
        <id>https://null-go.github.io/post/js-lei-shu-zu-dui-xiang-he-ke-die-dai-dui-xiang/</id>
        <link href="https://null-go.github.io/post/js-lei-shu-zu-dui-xiang-he-ke-die-dai-dui-xiang/">
        </link>
        <updated>2021-03-15T09:35:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="array-like-objects-类数组对象">array-like objects (类数组对象)</h1>
<p><strong>即类似于数组的对象，有若干索引属性和length属性</strong><br>
一些 JavaScript 对象, 例如 document.getElementsByTagName() 返回的 NodeList 或者函数内部可用的 arguments 对象，他们表面上看起来，外观和行为像数组，但是不共享他们所有的方法。例如 arguments 对象就提供一个 length 属性，但是不实现 forEach() 方法。<br>
这个时候若想让类数组对象使用数组的方法，可以使用<strong>方法借用</strong>的方式让数组原型上的某个方法调用apply，因为许多数组的方法内部实现均使用this，改变方法内部的this即可以使该方法作用于类数组对象。</p>
<h1 id="iterable-object可迭代对象">Iterable object（可迭代对象）</h1>
<p>要成为可迭代对象，对象必须实现 <strong>@@iterator方法</strong>，这意味着该对象或它的原型链上的对象有@@iterator方法，可通过常量<strong>Symbol.iterator</strong>访问该属性。<br>
该方法的返回值为一个对象(<strong>迭代器</strong>)，该对象必须含有next()方法，next的返回值是一个对象，该对象包含两个属性：</p>
<blockquote>
<p>done（boolean）<br>
如果迭代器可以产生序列中的下一个值，则为 false。（这等价于没有指定  done 这个属性。）<br>
value<br>
迭代器返回的任何 JavaScript 值。done 为 true 时可省略。</p>
</blockquote>
<p>可迭代对象：Array，Set，String，Map，DOM集合<br>
for..of..语句专用于可迭代对象，<strong>展开语法</strong> , <strong>解构赋值</strong> 的实现依赖于可迭代对象</p>
<p>#将类数组对象和可迭代对象转化为真正的数组<br>
<strong>使用全局方法 Array.from()</strong>   Array.from(arrayLike[, mapFn[, thisArg]]);<br>
arrayLike：想要转换成数组的类数组对象或可迭代对象。<br>
mapFn：可选， 如果指定了该参数，新数组中的每个元素会执行该回调函数。即map(映射)函数<br>
thisArg：可选，指定回调函数的this值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】this 指向]]></title>
        <id>https://null-go.github.io/post/js-this-zhi-xiang/</id>
        <link href="https://null-go.github.io/post/js-this-zhi-xiang/">
        </link>
        <updated>2021-03-13T07:59:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="this的指向问题的几个重点">this的指向问题的几个重点</h2>
<ol>
<li>this可以用于任何函数或者方法。</li>
<li>this是不受限制的。</li>
<li>在 JavaScript 中，this 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于函数声明的位置，而是取决于在“点符号前”的是什么对象。</li>
</ol>
<h1 id="作为对象的方法调用this指向本对象且this靠近最后一个对象">作为对象的方法调用，this指向本对象，且this靠近最后一个对象</h1>
<h1 id="对象原型上的方法中的this依然会指向new构造出来的对象实例上一条的拓展">对象原型上的方法中的this依然会指向new构造出来的对象实例(上一条的拓展)</h1>
<h1 id="在对象的构造函数中使用new方法this指向构造的那个对象">在对象的构造函数中，使用new方法，this指向构造的那个对象</h1>
<h1 id="作为普通的函数调用严格模式在this指向undefined非严格模式下指向全局函数浏览器window">作为普通的函数调用，严格模式在this指向undefined，非严格模式下指向全局函数(浏览器window)</h1>
<h1 id="匿名函数this指向window若在绑定事件处理函数时传递匿名函数作为参数则作为参数的匿名函数中的this指向绑定事件处理函数的元素">匿名函数this指向window，若在绑定事件处理函数时传递匿名函数作为参数，则作为参数的匿名函数中的this指向绑定事件处理函数的元素</h1>
<h1 id="箭头函数的this值来自闭合词法上下文的值也就是说箭头函数的this在函数创建时就已经绑定好了这与其他函数情况不同this传递给call-bind-或者apply来调用箭头函数它将被忽略">箭头函数的this值来自闭合词法上下文的值(也就是说，箭头函数的this在函数创建时就已经绑定好了，这与其他函数情况不同，this传递给call、bind、或者apply来调用箭头函数，它将被忽略)</h1>
<p><strong>修改this指向</strong><br>
<em>apply/call</em>方法 立即执行 func.call(context, arg1, arg2, ...) func.apply(context, args)类数组对象<br>
apply 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。<br>
<em>bind</em> 复制一份新的函数<br>
bind(context,arg1,arg2,..) 除了绑定上下文，还能预定给函数传入参数，在复制后的函数调用时自动传入，同时调用时传入的参数在预定参数之后传入。（这种方式称为<em>偏函数</em>）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【ES6】语法简学]]></title>
        <id>https://null-go.github.io/post/es6-yu-fa-jie-xi/</id>
        <link href="https://null-go.github.io/post/es6-yu-fa-jie-xi/">
        </link>
        <updated>2021-03-12T02:41:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="let-和-const命令">let 和 const命令</h1>
<ol>
<li>块级作用域和函数声明<br>
ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br>
但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，不会报错。<br>
ES6中明确规定，函数在块级作用域中声明类似于let，在块级作用域外不可见。<br>
但是如果<strong>浏览器</strong>都明确遵守ES6中的函数声明，那必然会对老代码产生巨大的影响，所以<strong>浏览器</strong>(其他环境遵循ES6)有以下三条规则:</li>
</ol>
<blockquote>
<p>允许在块级作用域内声明函数。<br>
函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>
同时，函数声明还会提升到所在的块级作用域的头部。</p>
</blockquote>
<ol start="2">
<li>
<p>const<br>
const声明的同时必须初始化，仅在块级作用域中有效，存在暂时性死区，不可重复声明。<br>
const表示值不能发生改变，const声明的变量若等于简单类型数据，指变量的值不能发生改变，若等于引用类型数据，指变量指向的地址不能改变，但地址指向的数据结构可以改变。</p>
</li>
<li>
<p>顶层对象的属性<br>
顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。(var 和 function定义的全局变量会成为顶层对象的属性)。顶层对象是一个有实体含义的对象，也是不合适的。<br>
ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
</li>
<li>
<p>globleThis对象<br>
JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。</p>
</li>
</ol>
<h1 id="变量解构赋值">变量解构赋值</h1>
<h1 id="class语法">Class语法</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Vue】解决动态绑定本地图片的问题]]></title>
        <id>https://null-go.github.io/post/vue-jie-jue-dong-tai-bang-ding-ben-di-tu-pian-de-wen-ti/</id>
        <link href="https://null-go.github.io/post/vue-jie-jue-dong-tai-bang-ding-ben-di-tu-pian-de-wen-ti/">
        </link>
        <updated>2021-03-09T14:19:41.000Z</updated>
        <content type="html"><![CDATA[<p>一开始出现这个问题是源自于Vue组件化，将一个复用的模块做出组件后，要求向子组件传递一个src引用一张<strong>本地</strong>的图片，传递过去src是一个变量，在img标签中单向绑定<strong>v-bind:src=</strong>。发现出错了，上网查找资料后发现是webpack的问题，webpack会将assets文件夹处理解析为<strong>模块依赖</strong>，具体原因不知道，因为对webpack还不了解😥😢。<br>
然后尝试require纯地址路径，还是error找不到module，最终解决，解决方法：<strong>require(path) ,path</strong>至少要有三部分组成, 目录+文件名+后缀，即：</p>
<pre><code>&lt;img :src=&quot;require('../../assets/images/'+pic+'.png')&quot;&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【AJAX】同步和异步HTTP请求 混编模式]]></title>
        <id>https://null-go.github.io/post/ajax-tong-bu-he-yi-bu-http-qing-qiu-yi-hun-bian-mo-shi/</id>
        <link href="https://null-go.github.io/post/ajax-tong-bu-he-yi-bu-http-qing-qiu-yi-hun-bian-mo-shi/">
        </link>
        <updated>2021-03-09T00:29:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="web开发混编模式">web开发混编模式</h2>
<p>在html中嵌入php，jsp，asp等脚本语言(前后端不分离)，通过url地址请求页面加载不同的HTML页面的内容，所以每次页面有变化都需要重新请求服务器并等待服务器返回的HTML页面重新渲染，这样的方式是同步的。(用户必须等待服务器的返回后才进行其他操作)</p>
<h2 id="mvc模式">MVC模式</h2>
<h2 id="ajax-asynchronous-javascript-and-xml异步-javascript-和-xml">AJAX (“Asynchronous Javascript And XML”异步 JavaScript 和 XML)</h2>
<p>前端使用JavaScript的方法直接向服务器发起HTTP请求，获取XML/JSON等数据后进行处理，在不刷新页面的情况在操作HTML以达到重新渲染页面的作用。</p>
<h2 id="原生xmlhttprequest对象">原生XMLHttpRequest对象</h2>
<p>XMLHttpRequest对象是js引擎内置的构造对象，IE5或6没有此对象，要使用ajax必须要用ActiveXObject对象。</p>
<pre><code>if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ...
    httpRequest = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE 6 and older
    httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
</code></pre>
<p>方法和属性</p>
<ul>
<li>open &lt;初始化请求&gt; <code>.open(参数1,参数2,参数3)</code><br>
参数1:请求的方法 即&quot;GET&quot; &quot;POST&quot; &quot;HEAD&quot;<br>
参数2:请求的url<br>
参数3:可选，表示是否异步 true为异步</li>
<li>send &lt;发送请求&gt;</li>
<li>setRequestHeader &lt;设置请求头&gt;<br>
在POST 请求要传递参数时 必须要在open()之后 send()之前 调用xhr.setRequestHeader(header, value);<br>
发送JSON数据格式<br>
setRequestHeader(&quot;Content-type&quot;,&quot;application/json&quot;);<br>
发送表单数据格式<br>
setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</li>
<li>onreadystatechange &lt;处理响应&gt; 将函数挂载在该属性上，在http请求的状态发生改变时会调用该回调函数。</li>
<li>readyState 可读属性 返回一个 XMLHttpRequest 代理当前所处的状态。一个 XHR 代理总是处于下列状态中的一个：
<ol>
<li>0 (XMLHttpRequest.UNSENT) 代理被创建，但尚未调用 open() 方法。</li>
<li>1 (XMLHttpRequest.OPENED) open() 方法已经被调用。</li>
<li>2 (XMLHttpRequest.HEADER_RECEIVED) send() 方法已经被调用，并且头部和状态已经可获得。</li>
<li>3 (XMLHttpRequest.LOADING) 下载中； responseText 属性已经包含部分数据。</li>
<li>4 (XMLHttpRequest.DONE) 下载操作已完成。<br>
注意与<strong>status</strong>属性区分，status属性表示<strong>响应中</strong>的数字状态码，status 的值是一个无符号短整型。在请求完成前，status的值为0。如果 XMLHttpRequest 出错，浏览器返回的 status 也为0。</li>
</ol>
</li>
<li>response 可读属性 返回响应的正文。类型可以有很多种： ArrayBuffer 、 Blob 、 Document 、 JavaScript Object 或 DOMString；取决于responseType类型。</li>
<li>response 可读属性 返回响应的DOMString 类型的文本信息。<br>
当DOMString 为null时，表示请求失败了。当DOMString 为&quot;&quot;时，表示这个请求还没有被send()<br>
当请求状态readyState变为XMLHttpRequest.DONE (4)，且status值为200（&quot;OK&quot;）时，responseText是全部后端的返回数据</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【CSS】基础知识汇总]]></title>
        <id>https://null-go.github.io/post/css-ji-chu/</id>
        <link href="https://null-go.github.io/post/css-ji-chu/">
        </link>
        <updated>2021-03-07T03:12:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="引入css文件的三种形式">引入CSS文件的三种形式</h2>
<ol>
<li>外部样式表<br>
即用link标签 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;</code> 一般放在head标签里面的最后一个</li>
<li>内部样式表<br>
即用<code>style</code>标签引用 也是放在head标签最后一个</li>
<li>内联样式(难以维护，可读性变差)<br>
即在元素内部使用 style属性加入css样式</li>
</ol>
<h2 id="浏览器加载网页是怎么样加载的">浏览器加载网页是怎么样加载的</h2>
<ol>
<li>浏览器将 HTML文件渲染成一个DOM树，该过程为深度遍历</li>
<li>构建DOM树的同时，拉取额外资源，如图片，css，js文件(当遇到js代码时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构)</li>
<li>当CSS解析完后生成CSS规则树(CSS rule tree)</li>
<li>将CSS规则树与DOM树合并，构建渲染树（rendering tree）<br>
<img src="https://upload-images.jianshu.io/upload_images/8646214-c6a28b94fa802b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641/format/webp" alt="avatar" loading="lazy"><br>
为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</li>
<li>布局和绘制</li>
</ol>
<h2 id="选择器">选择器</h2>
<ol>
<li>类选择器</li>
</ol>
<ul>
<li>指向特定元素的类 类后面.className，例span.span-1</li>
<li>多个类被应用时指向一个元素 两个类名连写，例.divBox.danger</li>
</ul>
<ol start="2">
<li>标签属性选择器  根据标签上的属性匹配值</li>
</ol>
<ul>
<li>[attr] 匹配带有attr属性的元素，例a[title] 匹配a标签且有title属性</li>
<li>[attr=&quot;value&quot;] 匹配带有attr属性的元素，且属性的值仅为value，不能有多个，例一个div元素有class=&quot;divOne divTwo&quot;  div[class=&quot;divOne&quot;]无法匹配它</li>
<li>[attr~=&quot;value&quot;] 解决了上述情况 单个值能匹配，多个属性值也能匹配(注:<strong>值是用空格隔开的</strong>)</li>
<li>[attr|=&quot;value&quot;] 可以匹配恰好为value的属性值，也可以匹配值value后面紧随一个连字符的值<br>
注：连字符 <strong>-</strong> [class|=&quot;div&quot;] 可以匹配class=&quot;div-1234&quot;<br>
除此之外，还有 <em>三个子字符串匹配选择器</em></li>
</ul>
<ol start="3">
<li>关系选择器</li>
</ol>
<ul>
<li>空格 <strong>后代选择器</strong>，特点是继承关系长，间接子元素也能匹配</li>
<li>&gt;  <strong>子代关系选择器</strong>，特点是只有直接子代能匹配</li>
<li>+ <strong>邻接兄弟选择器</strong>，特点是同级且必须在前者之后邻接才能匹配，注：匹配的是+后面的元素</li>
<li>~ <strong>通用兄弟选择符</strong>，特点是同级且不需要邻接，只需要之后，注：匹配的是~后面的元素<br>
tips: css样式匹配是从右往左 从DOM树叶子节点往根节点进行寻找匹配<br>
以便<em>尽早过滤掉一些无关的样式规则和元素</em></li>
</ul>
<h2 id="属性">属性</h2>
<p>width和min-width 当width内容多于宽度时 内容换行 min-width设置横向滚动条<br>
overflow 要隐藏移除的部分 hidden 隐藏 scroll 一直有滚动条 auto 溢出自动有滚动条<br>
font-size设置字体高度 font-weight 有些字体没有某些属性 font-style italic斜体属性 color 字体颜色 transparent透明色<br>
oblique两者都是斜体 当字体没有italic属性时，oblique强制倾斜<br>
em默认样式是斜体，当设置font-style:normal;时，代表这是个强调的标签，但强调的方式不一定是斜体。<br>
画一个红色下角的三角形</p>
<pre><code>{ 
    height: 0px;
    width: 0px;
    border-width: 100px;
    border-style: solid;
    border-color: transparent;
    border-bottom-color: red;
}
</code></pre>
<p>line-height 一行文本的高度，line-height = height 盒子内部文本垂直居中(单行文本)<br>
相对单位：<br>
em 在font-size中设置是相对于父元素的字体大小，在别的元素中是相对于自己的字体大小<br>
1 em = 16px; 1px = 0.0625em 10px = 0.625em</p>
<pre><code>html {
    font-size:62.5%; // 1 em = 10px
}
//行高设置字体高度的1.2倍
line-height : 1.2em;
</code></pre>
<p>rem 相对于根元素的字体大小 rem<br>
vw vh 相对于视图窗口的宽高 1%<br>
单行文本截断和显示省略号三大件:   white-space:nowrap; 不换行 overflow-x:hidden; 溢出部分隐藏 ;text-overflow:ellipsis 隐藏部分加省略号<br>
label for属性和 input id属性相关联<br>
opacity: .5 兼容性 filter:alpha(opacity:50)<br>
伪类和伪元素<br>
伪类:<br>
:hover :first-child :last-child :nth-child(可填odd奇数|even偶数|普通数字) 第n个子元素 选择框:checed<br>
容器内多行文本居中，容器display设置table，容器中的文本display设置成table-cell，容器中的文本vertical-align设置成middle<br>
行内元素和行内块元素之间的文本分隔符，vertical-align对行内块级元素的影响<br>
textarea换行写中间没有文字会有文本分隔符<br>
外层盒子固定宽高加一个padding 内层盒子宽高100%相当于居中了<br>
box-sizing: border-box兼容性问题<br>
background-color 包括padding以内<br>
position: relative 保留原来文档流的位置 absolute不保留<br>
设置absolute相对于最近的定位父元素<br>
border-width只有在border-style 不为none时才有用，否则会被重置为0<br>
当两个盒子排列 前面的盒子定位为 absolute 后面未定位，那么前面盒子脱离文档流后 后面的盒子会流动上去，但是前面定位为absolute的盒子会在后面的盒子的上面，此时将后面的盒子同样设置为定位元素(如 relative) 这时后面的盒子会在前面的盒子的上面 (改变层级还能用z-index)<br>
span position设为absolute后display变为block了 元素float后display为inline-block</p>
]]></content>
    </entry>
</feed>