<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://null-go.github.io</id>
    <title>PILOT</title>
    <updated>2021-05-01T03:36:35.370Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://null-go.github.io"/>
    <link rel="self" href="https://null-go.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://null-go.github.io/images/avatar.png</logo>
    <icon>https://null-go.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, PILOT</rights>
    <entry>
        <title type="html"><![CDATA[【JS】事件循环]]></title>
        <id>https://null-go.github.io/post/js-shi-jian-xun-huan/</id>
        <link href="https://null-go.github.io/post/js-shi-jian-xun-huan/">
        </link>
        <updated>2021-05-01T03:33:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="事件循环">事件循环</h1>
<p><strong>JavaScript语言是一门单线程语言，所有的异步任务都是用同步来模拟的。事件循环 Event Loop是JavaScript的执行机制。</strong></p>
<p>同步任务是指：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p>
<p>异步任务指的是，不进入主线程、而进入<strong>任务队列</strong>的任务，只有<strong>任务队列</strong>通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。异步任务分为<strong>微任务</strong>和<strong>宏任务</strong>。</p>
<img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom: 50%;" />
<p><strong>微任务</strong>和<strong>宏任务</strong>是两个不同的 <strong>Event Queue</strong></p>
<p>Event Table：比如 setTimeout(fn,3000); 将 setTimeout函数扔进 Event Table，3秒后为其注册回调函数 fn 并放进Event Queue中。</p>
<img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;" />
<h2 id="微任务与宏任务">微任务与宏任务</h2>
<p>事件循环的概念：一个在 JavaScript 引擎<strong>等待任务</strong>，<strong>执行任务</strong>和<strong>进入休眠状态等待更多任务</strong>这几个状态之间转换的无限循环。</p>
<p>事件循环负责<strong>收集事件</strong>（包括用户事件以及其他非用户事件等）、<strong>对任务进行排队</strong>以便在合适的时候执行回调。然后它<strong>执行</strong>所有处于等待中的 <strong>一个JavaScript 任务（宏任务）</strong>，然后是<strong>所有微任务</strong>，然后执行一些<strong>必要的渲染和绘制操作</strong>。直到本次循环宏任务队列中的任务全部出队，一次循环结束。</p>
<p><strong>任务示例：</strong></p>
<ol>
<li>当外部脚本 <code>&lt;script src=&quot;...&quot;&gt;</code> 加载完成时，任务就是执行它(第一个script标签是第一个宏任务)。</li>
<li>当用户移动鼠标时，任务就是派生出 <code>mousemove</code> 事件和执行处理程序。<strong>事件</strong></li>
<li>当安排的（scheduled）<code>setTimeout</code> 时间到达时，任务就是执行其回调。<strong><code>setTimeout</code>和<code>setInterval</code>函数</strong></li>
<li>......诸如此类</li>
</ol>
<p>多个任务组成了一个队列，即所谓的<strong>宏任务队列</strong>。</p>
<p>队列中的任务基于<strong>先进先出的</strong>原则执行。</p>
<blockquote>
<p>引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。(我们的函数可能会创建很多元素，将它们一个接一个地插入到文档中，并更改其样式 —— 访问者不会看到任何未完成的“中间态”内容)</p>
<p>如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。</p>
</blockquote>
<p>**微任务实例：**原生Promise , process.nextTick , MutationObserver , Promise.resolve(11).then 后面的回调函数也丢进微任务队列</p>
<p>宏任务队列和微任务队列的<strong>区别</strong>很简单，但却很重要：</p>
<ul>
<li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要<strong>在下一次迭代开始之后才会被执行</strong>.</li>
<li>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</li>
</ul>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210417204815996.png" alt="image-20210417204815996" style="zoom:80%;" />
<pre><code class="language-javascript">let promise = Promise.resolve(&quot;微任务&quot;);
setTimeout(() =&gt; {
  console.log(&quot;宏任务&quot;); // 宏任务。
});
promise.then((result) =&gt; {
  console.log(result);
  new Promise((resolve, reject) =&gt; {
    resolve(&quot;额外添加的微任务&quot;);
    // 在微任务期间添加的微任务
  }).then((result) =&gt; {
    console.log(result);
  });
}); // 微任务

// 打印：
// 微任务
// 额外添加的微任务
// 宏任务
</code></pre>
<pre><code class="language-javascript">console.log('global')

for (var i = 1;i &lt;= 5;i ++) {
  setTimeout(function() {
    console.log(i)
  },i*1000)
  console.log(i)
}

new Promise(function (resolve) {
  console.log('promise1')
  resolve()
 }).then(function () {
  console.log('then1')
})

setTimeout(function () {
  console.log('timeout2')
  new Promise(function (resolve) {
    console.log('timeout2_promise')
    resolve()
  }).then(function () {
    console.log('timeout2_then')
  })
}, 1000)
// 输出
// global
// 1 2 3 4 5
// promise 1
// then 1
// 6
// timeout2
// timeout2_promise
// timeout2_then
// 6 6 6 6
</code></pre>
<pre><code class="language-javascript">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】异步解决方案(Promise Generator)]]></title>
        <id>https://null-go.github.io/post/js-yi-bu-jie-jue-fang-an-promise-generator/</id>
        <link href="https://null-go.github.io/post/js-yi-bu-jie-jue-fang-an-promise-generator/">
        </link>
        <updated>2021-04-16T09:31:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="异步解决方案">异步解决方案</h1>
<h2 id="promise-对象">Promise 对象</h2>
<h3 id="特点">特点</h3>
<ol>
<li>状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>(很多时候称为<code>resolved</code>)（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。(抛出错误同样能改变状态为rejected)</li>
<li>一旦新建就立即执行，无法中途取消。</li>
</ol>
<pre><code class="language-javascript">let promise = new Promise(function(resolve, reject) {
  // executor code 
  // 这里的代码会立即执行
  /*
  if() {
  resolve();
  }
  else {
  reject();
  }
  进行一些异步操作
  */
});
</code></pre>
<ol start="4">
<li><code>resolve/reject</code> 函数只需要一个参数（或不包含任何参数），并且将忽略额外的参数。</li>
</ol>
<blockquote>
<p>如果状态改变已经发生了，再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
</blockquote>
<h3 id="基本用法">基本用法</h3>
<p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<code>resolve</code>函数把<code>Promise</code>对象的状态从<code>pending</code>变为<code>fulfilled</code>,reject函数把<code>Promise</code>对象的状态从<code>pending</code>变为<code>rejected</code></p>
<h3 id="链式调用及错误处理">[链式调用]及[错误处理]</h3>
<h4 id="then-thenonfulfilledonrejected">.then then(onFulfilled,onRejected)</h4>
<p>**.then 方法：**接受两个回调函数(均可选)，第一个回调函数在状态变为<code>fulfilled</code>时调用，第二个回调函数在状态变为<code>rejected</code>时调用。也可以只传入一个函数。<br>
<img src="https://null-go.github.io/post-images/1618657450279.png" alt="" loading="lazy"><br>
<strong>.then：</strong> 特别注意这个新的<code>Promise</code>对象将以回调的返回值(该值不是新创建的Promise)来 <code>resolve</code>自己( <strong>代码一</strong>，所以此时的then会立即执行 )。若返回一个新Promise对象，相当于把默认的行为取消掉了( <strong>代码二</strong>，此时的then会等到返回的promise对象状态改变时执行 )。</p>
<pre><code class="language-javascript">new Promise((resolve) =&gt; {
  resolve(1);
})
  .then((result) =&gt; {
    console.log(result); //输出 1
    return result * 2; //.then 创建的promise对象默认return 即 resolve 了;
  })
  .then((result) =&gt; {
    console.log(result); // 输出 2
    return result * 2;
  });
</code></pre>
<p>我们可以在 <code>.then</code> 中显示的创建一个新的<code>Promise</code> 对象并 <code>return</code></p>
<pre><code class="language-javascript">new Promise((resolve) =&gt; {
  resolve(1);
})
  .then((result) =&gt; {
    console.log(result); //输出 1
    return new Promise((resolve) =&gt; {
      setTimeout(() =&gt; {
        resolve(result * 2);
      }, 1000);
    }); // 改造成显示的 return 一个新的promise 对象
  })
  .then((result) =&gt; {
    console.log(result); // 输出 2 有一秒的延迟
    return result * 2;
  });
</code></pre>
<h4 id="catch-catchonrejected">.catch catch(onRejected)</h4>
<p><code>.catch</code>的行为等价于 .then(null,onRejected)。</p>
<figure data-type="image" tabindex="1"><img src="https://null-go.github.io/post-images/1618657494721.png" alt="" loading="lazy"></figure>
<p>使用 <code>throw</code>语法抛出<code>Error</code>错误，catch 可以接收到。throw 抛出的错误会一直向链后冒泡，直到<code>.then</code>中的第二个函数捕获或catch方法捕获。</p>
<pre><code class="language-javascript">// 抛出错误
new Promise((resolve,reject)=&gt;{
  throw new Error('抛出错误');
  // 等价于
  reject(new Error('抛出错误'));
})
</code></pre>
<p>当在<strong>Promise</strong>中抛出了错误（或产生了语法错误）却没有被捕获时，JavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error。这个error不会影响外部代码的继续执行。</p>
<p>看下列问题：</p>
<figure data-type="image" tabindex="2"><img src="https://null-go.github.io/post-images/1618657518552.png" alt="" loading="lazy"></figure>
<p>.catch 会被触发吗？不会。<strong>在Promise内同步的代码抛出的错误会被当成 rejected来处理，所有同步的错误可以被catch到</strong>，但现在不是同步的，故catch无法捕获错误( 控制台会打印出错误 )。</p>
<p>// check: 这和事件轮询有关吗</p>
<h4 id="finally-finallyonfinally">.finally finally(onFinally)</h4>
<p><code>finally()</code>是在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数（即<code>onFinally</code>）。</p>
<p><code>onFlinally</code> 回调函数不接受任何参数。它仅用于无论最终结果如何都要执行的情况。这表明，<code>finally</code>里的操作应该是不依赖于<code>Promise</code>状态和执行结果的。</p>
<h3 id="常见api">常见API</h3>
<h4 id="promiseall">Promise.all()</h4>
<p>参数：可迭代的Promise对象(通常传递数组)</p>
<p>返回值：一个新的Promise对象</p>
<ul>
<li>
<p>返回值的Promise对象：<code>resolve</code>回调执行是在所有输入的promise的resolve回调都结束，返回值是传入参数的数组;<code>reject</code>回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p>
</li>
<li>
<p>结果数组中元素的顺序与其在源 promise 中的顺序相同。即使第一个 promise 花费了最长的时间才 resolve，但它仍是结果数组中的第一个。</p>
</li>
<li>
<p>如果传入的可迭代对象为空，<code>Promise.all</code> 会同步地返回一个已完成（resolved）状态的<code>promise</code>。</p>
</li>
<li>
<p>如果参数中包含非 <code>promise</code> 值，这些值将被忽略，但仍然会被放在返回数组中（如果 <code>promise</code> 完成的话）</p>
</li>
</ul>
<h4 id="promiserace">Promise.race()</h4>
<p>与 <code>Promise.all</code> 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。</p>
<h4 id="promiseresolve-reject">Promise.resolve() / reject()</h4>
<p><code>Promise.resolve(value)</code> 用结果 <code>value</code> 创建一个 resolved 的 promise。如同：</p>
<pre><code class="language-javascript">Promise.resolve(value);
let promise = new Promise(resolve =&gt; resolve(value));
</code></pre>
<h3 id="promise-包装器">Promise 包装器</h3>
<h3 id="微任务-microtask">微任务 Microtask</h3>
<pre><code class="language-javascript">let p = Promise.resolve(3);
p.then((res) =&gt; {
  console.log(res);
});
console.log(&quot;code finished&quot;);
// 先输出 code finished 后输出3
</code></pre>
<p><strong>异步任务需要适当的管理。为此，ECMA 标准规定了一个内部队列 <code>PromiseJobs</code>，通常被称为“微任务队列（microtask queue）”（ES8 术语）。</strong></p>
<ul>
<li>队列是先进先出的，首先进入队列的任务会先被执行。</li>
<li>只有在JavaScript引擎没有其他任务运行时，任务队列中的任务才会被执行。</li>
</ul>
<h3 id="async-await">async | await</h3>
<h4 id="async-function">async function</h4>
<pre><code class="language-javascript">async function f(){
    return {name:'黄'};
}
// &lt;-&gt; 等价于
function f(){
    return Promise.resolve({name:'黄'}); 
}
// 通过 .then 拿到async函数的返回值
f().then(result=&gt;{
    console.log(result); // 输出 {name:'黄'}
})
</code></pre>
<p><strong>async函数一定会返回一个Promise对象，如果一个async函数的返回值看起来不是promise，那么它将会被隐式地包装在一个promise中。</strong></p>
<h4 id="只在async函数内起作用的await">只在async函数内起作用的await</h4>
<p><code>async</code>/<code>await</code>的目的为了简化使用基于promise的API时所需的语法。</p>
<p>await代替我们进行了等待，就像<code>.then</code>和<code>.catch</code>此类方法中传入的回调函数的参数，<code>async</code>/<code>await</code>的行为就好像搭配使用了生成器和promise。</p>
<pre><code>.then(result=&gt;{},error=&gt;{})  
let result = await new Promise((resolve,reject)=&gt;{
     resolve(11); // 直接拿到Promise执行后的结果了 不需要.then 
})
</code></pre>
<p><strong>await表达式会暂停整个async函数的执行进程并出让其控制权(交给外部函数)，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。当await将async函数执行进程暂停时，JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件</strong></p>
<p><strong>await后跟一个promise，该promise的解决值会被当作该await表达式的返回值。</strong></p>
<p><strong>如果一个 promise 正常 resolve，<code>await promise</code> 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 <code>throw</code> 语句那样。</strong></p>
<pre><code class="language-javascript">// await 后的Promise被 reject了
async function f() {
  await Promise.reject(new Error(&quot;Whoops!&quot;));
}
// &lt;-&gt; 等价于 
async function f(){
  throw new Error(&quot;Whoops!&quot;)  
}
// await 中的Promise抛出了错误
async function foo() {
  await new Promise((resolve, reject) =&gt; {
    resolve(1);
  });
  await new Promise((resolve, reject) =&gt; {
    resolve(2);
  });
  await new Promise((resolve, reject) =&gt; {
    reject(new Error(&quot;错误&quot;));  // &lt;-等价于-&gt; throw new Error(&quot;错误&quot;);
  });
}
foo().then(null, (error) =&gt; {
  console.log(error);   // 拿到了错误 
});
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://null-go.github.io/post-images/1618657542313.png" alt="" loading="lazy"></figure>
<p>上述 foo() 调用过程中，第三个<code>await</code>后接的Promise被rejected了，<strong>该async函数隐式返回了一个被rejected的Promise对象</strong>。这说明了在<code>async</code>中多次使用<code>await</code>，若有<code>await</code>后跟的Promise对象抛出了错误或者是rejected了。async函数它将自动捕获异常，<strong>async函数执行中断</strong>，并通过隐式返回rejected Promise将错误传递给出去。</p>
<h2 id="generator-function-和-生成器对象">Generator function 和 生成器对象</h2>
<h3 id="generator函数生成器函数-function">Generator函数(生成器函数)  function*</h3>
<p>Generator 函数与常规函数的行为不同。在此类函数被调用时，它<strong>不会运行其代码</strong>。而是返回一个被称为''<strong>generator object</strong>''的特殊对象，来管理执行流程。</p>
<p><strong>生成器函数：即产生<code>生成器对象</code>的函数，生成器对象符合可迭代协议和迭代器协议，他们是可迭代的</strong></p>
<pre><code class="language-javascript">function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
// &quot;generator function&quot; 创建了一个 &quot;generator object&quot;
let generator = generateSequence();
alert(generator); // [object Generator]
</code></pre>
<h4 id="next-方法">next() 方法</h4>
<p>当 <code>next()</code> 被调用时，Generator函数运行到第一个 <strong>yield</strong> 结束之前。返回一个对象，该对象有两个属性：</p>
<ul>
<li>
<p><code>value</code>属性即 yield 后跟的值(没有值默认为undefined)。</p>
</li>
<li>
<p><code>done</code>属性即 <code>generator</code> 函数是否执行完。</p>
</li>
</ul>
<p>当 generator 函数执行到 return 语句时，函数结束(没有return 默认最后return undefined，这与普通函数一致)。</p>
<blockquote>
<p>return 后的值也是一个对象，与yield类似，value属性为return的值，done属性为true。</p>
<p>如果我们在 return 后再次调用 next() 方法，同样返回最后一次return 的结果。</p>
</blockquote>
<h3 id="generator-是可迭代的">Generator 是可迭代的</h3>
<p>因为 Generator 对象是可迭代的，所有它可以使用所有可迭代对象的通用方法。</p>
<ol>
<li>使用 for of 遍历 Generator  对象</li>
</ol>
<p><code>done: true</code> 时，<code>for..of</code> 循环会忽略最后一个 <code>value</code>。因此，如果我们想要通过 <code>for..of</code> 循环显示的结果，我们必须使用 <code>yield</code> 返回它们。</p>
<ol start="2">
<li>使用 <code>...spread</code> 语法</li>
</ol>
<p>同样会忽略 <code>done:true</code>的值。</p>
<h4 id="generator-和-iterator-的比较">Generator 和 iterator 的比较:</h4>
<p><strong>iterator：</strong></p>
<pre><code class="language-javascript">let range = {
  from: 1,
  to: 5,
  // for..of range 在一开始就调用一次这个方法 生成迭代器对象 iterator object
  [Symbol.iterator]() {
    // ...它返回 iterator object：
    // 后续的操作中，for..of 将只针对这个对象，并使用 next() 向它请求下一个值
    return {
      current: this.from,
      last: this.to,
      // for..of 循环在每次迭代时都会调用 next()
      next() {
        // 它应该以对象 {done:.., value :...} 的形式返回值
        if (this.current &lt;= this.last) {
          return { value: this.current++, done: false };
        } else {
          return { value: this.current, done: true };
        }
      },
    };
  },
};
for (item of range) {
  console.log(item); // 输出 1 2 3 4 5
}
console.log([...range]); // 输出 [1,2,3,4,5]
</code></pre>
<p><strong>Generator：</strong></p>
<pre><code class="language-javascript">let range = {
  from: 1,
  to: 5,
  // 调用该方法直接返回了一个 迭代器对象 iterator Object
  *[Symbol.iterator]() {
    for (; this.from &lt;= this.to; this.from++) yield this.from; //yield相当于next()
  },
};
for (item of range) {
  console.log(item); // 输出 1 2 3 4 5
}
console.log([...range]); // 输出 [] 空数组 因为循环不会执行，又没有除return undefined以外的返回值了
</code></pre>
<p>因为 <code>[Symbol.iterator]</code> 方法现在 带 * 号，直接返回了一个迭代器对象 (</p>
<ul>
<li>它具有 <code>.next()</code> 方法 （Generator对象本身，隐式的）</li>
<li>next 方法有 <code>{value: ..., done: true/false}</code> 形式的返回值 （yield关键字实现的）</li>
</ul>
<p>)</p>
<h3 id="generator-组合">Generator 组合</h3>
<p>Generator 组合（composition）是 generator 的一个特殊功能，它允许透明地（transparently）将 generator 彼此“嵌入（embed）”到一起。</p>
<p>通过 yield* 实现：</p>
<pre><code class="language-javascript">function* aGeneratorMake(start, end) {
  for (let i = start; i &lt;= end; i++) {
    yield i;
  }
}
function* bGeneratorMake() {
  yield* aGeneratorMake(1, 3);
  yield* aGeneratorMake(4, 5);
}
let result = [];
for (item of bGeneratorMake()) {
  result.push(item);
}
console.log(result); // [1,2,3,4,5]
</code></pre>
<p><code>yield*</code> 指令将执行 <strong>委托</strong> 给另一个 generator。这个术语意味着 <code>yield* gen</code> 在 generator <code>gen</code> 上进行迭代，并将其产出（yield）的值透明地（transparently）转发到外部。就好像这些值就是由外部的 generator yield 的一样。</p>
<p>Generator 组合（composition）是将一个 generator 流插入到另一个 generator 流的自然的方式。它不需要使用额外的内存来存储中间结果。</p>
<h3 id="yield-是条双向路"><code>yield</code> 是条双向路</h3>
<p><code>yield</code>不仅可以将值传递到<code>generator</code>外面，还能从<code>generator</code>外面将值传入到里面。</p>
<p>调用 generator.next(arg);</p>
<figure data-type="image" tabindex="4"><img src="https://null-go.github.io/post-images/1618657594069.png" alt="" loading="lazy"></figure>
<p>**即：**当调用的是<code>next(arg)</code>,next包含参数，除第一次会忽略外，<code>arg</code>参数将会成为当前停止的yield的返回值。</p>
<h3 id="异步可迭代对象">异步可迭代对象</h3>
<p>改造可迭代对象：</p>
<ol>
<li>使用 <code>Symbol.asyncIterator</code> 取代 <code>Symbol.iterator</code>。</li>
<li><code>next()</code> 方法应该返回一个 <code>promise</code>（带有下一个值，并且状态为 <code>fulfilled</code>）。
<ul>
<li>关键字 <code>async</code> 可以实现这一点，我们可以简单地使用 <code>async next()</code>。</li>
<li>tip:<strong>因为我们必须保证next方法返回的是一个Promise，若不用 <code>async next()</code>而直接用单纯的<code>next()</code>,我们必须显式的返回一个Promise对象,<code>async</code>隐式的返回了一个Promise(fulfilled)</strong></li>
</ul>
</li>
<li>我们应该使用 <code>for await (let item of iterable)</code> 循环来迭代这样的对象。
<ul>
<li>注意关键字 <code>await</code>。</li>
<li>tip:<strong><code>await</code>是因为在next方法中返回的Promise，await可以得到Promise的值</strong></li>
</ul>
</li>
</ol>
<pre><code class="language-javascript">let obj = {
  first: 1,
  last: 5,
  // 将 Symbol.iterator 方法改为 Symbol.asyncIterator 方法
  [Symbol.asyncIterator]() {
    return {
      fir: this.first,
      lat: this.last,
      async next() {   // next 方法改为 async next
        await new Promise((resolve, reject) =&gt; {  // 可以在next方法中使用await了
          setTimeout(resolve, 1000);
        });
        if (this.fir &lt;= this.lat) {
          return {
            value: this.fir++,
            done: false,
          };
        } else {
          return {
            value: this.fir++,
            done: true,
          };
        }
      },
    };
  },
};
(async () =&gt; { // 创建一个async函数
  for await (const iterator of obj) { // await类型的 for of 循环可以使用了
    console.log(iterator);
  }
})();

// next 不加 async 关键词
next() {
  if (this.fir &lt;= this.lat) {
    return new Promise((resolve) =&gt; {
      resolve({
        value: this.fir++,
        done: false,
      });
    });
  } else {
    return new Promise((resolve) =&gt; {
      resolve({
        value: this.fir++,
        done: true,
      });
    });
  }
}
</code></pre>
<p>当使用<code>for of</code>时，它希望找到的是 <code>[Symbol.iterator]</code>方法，当使用 <code>async + for await for</code>时，它希望找到的是<code>[Symbol.asyncIterator]</code>方法。</p>
<h3 id="异步-generator">异步 Generator</h3>
<p>在<code>*function</code>前加上<code>async</code>，使生成器函数称为异步生成器函数。</p>
<pre><code class="language-javascript">async function* generatorMaker() {
  for (let i = 1; i &lt;= 5; i++) {
    // 显示的 yield promise
    yield new Promise((resolve) =&gt; {
      setTimeout(() =&gt; {
        resolve(i);
      }, 1000);
    });
    // yield i; 这是隐式的yield Promise，因为async函数的缘故 
  }
}
let gener = generatorMaker();
// 为了 用await接收 异步生成器函数 yield 回来的 Promise对象，创建了一个匿名的async函数
(async () =&gt; {
  let anwser = await gener.next();
  console.log(anwser); // 输出 {value : 1 ,done : false}
  for await (let item of gener) console.log(item); // 输出 2 3 4 5  for循环中只会返回 value部分
})();
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://null-go.github.io/post-images/1618657611806.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【CSS3】基础]]></title>
        <id>https://null-go.github.io/post/css3-ji-chu/</id>
        <link href="https://null-go.github.io/post/css3-ji-chu/">
        </link>
        <updated>2021-03-25T11:32:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="border-radius">border-radius</h1>
<p>单位：可以是 em rem vw等相对单位，还可以是百分比，相当于宽高。<br>
多值：4个 左上角开始顺时针 3个 左上-&gt;对角线-&gt;右下 2个 左上右下-&gt;右上左下<br>
拆分复合属性：左上 border-top/bottom-left/right-radius</p>
<h1 id="box-shadow">box-shadow</h1>
<p>语法：box-shadow: h-shadow v-shadow blur/模糊距离 spread/阴影大小 color inset;<br>
blur：意思是从外到里经过多远变得不模糊<br>
spread：阴影会向四周扩大的大小<br>
inset：当设置为inset属性时，阴影变为内侧阴影</p>
<pre><code>{
    box-shadow:20px 20px 20px 0px red inset
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://null-go.github.io/post-images/1616678037534.png" alt="" loading="lazy"></figure>
<h1 id="border-image">border-image</h1>
<p>没看懂暂时</p>
<h1 id="background-属性">background-*属性</h1>
<p>语法：<br>
background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</p>
<h2 id="background-img">background-img</h2>
<p>语法：background-img:url(&quot;&quot;);</p>
<h2 id="background-repeat">background-repeat</h2>
<p>设置背景图片的平铺 默认值repeat x,y轴平铺，repeat-x repeat-y no-repeat</p>
<h2 id="background-clip-背景裁剪显示的区域">background-clip 背景裁剪显示的区域</h2>
<p>值：border-box 默认 padding-box content-box</p>
<h2 id="background-position-背景图像的起始位置">background-position 背景图像的起始位置</h2>
<p>值：第一个值是水平位置 第二个值是垂直位置<br>
水平位置用left right center ，垂直位置用top center bottom，只写一个另外一个为center<br>
百分比 0% 0%，代表是left top 左上角也可以用，只写一个另外一个为50%<br>
x pos y pos，离起点的偏移量，只写一个另外一个为50%</p>
<h2 id="background-orgin-指定background-position属性应该是相对位置">background-orgin 指定background-position属性应该是相对位置</h2>
<p>值：padding-box 默认 border-box content-box</p>
<h1 id="渐变">渐变</h1>
<h2 id="线性渐变-沿着一根轴线改变颜色从一边拉向另一边">线性渐变 沿着一根轴线改变颜色(从一边拉向另一边)</h2>
<p><strong>语法一</strong>：linear-gradients(direction, color-stop1, color-stop2, ...);<br>
默认不写direction为从上到下 direction分兼容性<br>
若为 -webkit-内核 direction为开始方向，其他 内核 direction为结束方向<br>
若不写兼容性，direction 标准为 to direction<br>
<strong>语法二</strong>：linear-gradients(angle deg, color-stop1, color-stop2, ...);<br>
<img src="https://null-go.github.io/post-images/1616916263966.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【CSS】布局]]></title>
        <id>https://null-go.github.io/post/css-bu-ju/</id>
        <link href="https://null-go.github.io/post/css-bu-ju/">
        </link>
        <updated>2021-03-24T10:38:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="定位方案">定位方案</h1>
<ul>
<li>普通流(normal flow)     在普通文档流中的盒子属于一种<strong>格式化上下文</strong>（Formatting Context），常见的两种特殊的格式化上下文就是块格式化上下文（Block formatting context）和行内格式化上下文（Inline formatting context）。<br>
破坏性属性 👇 即破坏普通流</li>
<li>浮动(float) **脱离普通流。**在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移;  float属性最初只用于在成块的文本内浮动图像，文字环绕在它的左边或右边文本会环绕在它的周围，所以文本会环绕在浮动元素旁边。</li>
<li>绝对定位 absolute 或fixed(absolute positioning) <strong>脱离普通流。</strong><br>
https://www.cnblogs.com/chaixiaozhi/p/8481253.html</li>
</ul>
<h2 id="bfc">BFC</h2>
<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<h1 id="bfc特性">BFC特性：</h1>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠(BFC导致<strong>外边距折叠</strong>)</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此(BFC导致浮动元素可能遮盖其他元素，文本不会被遮盖，文本会环绕浮动元素)</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素(一种自适应特性)。反之也如此。(当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。)</li>
<li>计算BFC的高度时，浮动元素也参与计算(用来清除浮动)</li>
</ul>
<h1 id="产生bfc满足下列条件中的一个">产生BFC(满足下列条件中的一个)：</h1>
<ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ul>
<h1 id="bfc的作用">BFC的作用：</h1>
<ul>
<li>自适应两栏布局，aside栏设置float：left，固定宽高，main栏设置高度，不设定宽度，main一部分会被浮动元素遮盖(即使文字不会)，将main元素设置为BFC元素，利用BFC特性：BFC的区域不会与float box重叠，可以实现main区域自适应宽度</li>
<li>取消外边距折叠</li>
<li>清除浮动</li>
</ul>
<h1 id="浮动">浮动</h1>
<h2 id="工作原理浮动元素会脱离正常的文档布局流并吸附到其父容器的左边floatleft-在正常布局中位于该浮动元素之下的内容此时会围绕着浮动元素填满其右侧的空间">工作原理：浮动元素会脱离正常的文档布局流，并吸附到其父容器的左边(float:left)。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</h2>
<p>浮动元素表现的像inline-block一样</p>
<h2 id="清除浮动">清除浮动</h2>
<p>float会将元素变成内联块级元素<br>
float 父元素高度塌陷 清除浮动<br>
https://cssgridgarden.com/#zh-cn</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】DOM]]></title>
        <id>https://null-go.github.io/post/js-dom/</id>
        <link href="https://null-go.github.io/post/js-dom/">
        </link>
        <updated>2021-03-18T12:20:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="dom">DOM</h1>
<p>文档对象模型（Document Object Model）</p>
<p>document 对象是页面的主要入口点</p>
<h1 id="dom树"><strong>DOM树</strong></h1>
<p>每个HTML标签都是一个对象，标签内的文本也是一个对象。</p>
<p>标签称为元素节点，元素内的文本形成文本节点(一个文本节点只包含一个字符串，它总是叶子节点)</p>
<p><strong>空格和换行符</strong>都是完全有效的字符，它们可以形成文本节点。</p>
<blockquote>
<p>表格是一个有趣的“特殊的例子”。按照 DOM 规范，它们必须具有 &lt; tbody &gt;，但 HTML 文本却（官方的）忽略了它。然后浏览器在创建 DOM 时，自动地创建了 &lt; tbody &gt;。</p>
</blockquote>
<p>html 标签 document.documentElement</p>
<p>body 标签 document.body</p>
<p>head 标签 document.head</p>
<blockquote>
<p>在控制台中选中元素，且对其进行操作</p>
</blockquote>
<p>先选元素 然后按ESC $0是最后一次选择的元素 $1是前一个选择的元素</p>
<h2 id="查找"><strong>查找</strong></h2>
<p><strong>子节点</strong> 一层</p>
<p><strong>子孙节点</strong> 多层</p>
<p><strong>childNodes</strong>属性 集合列出了所有子节点，包括文本节点。</p>
<p><strong>首尾子节点</strong></p>
<p>如果元素存在子节点的 childNodes[0]==firstChild</p>
<p>​                               childNodes[childNodes.length - 1]==lastChild</p>
<p><strong>兄弟节点</strong>nextSibling previousSibling</p>
<p><strong>父节点</strong>parentNode</p>
<p>把这些属性加上Element关键词，即可忽略文本节点</p>
<ul>
<li>
<p>children — 仅那些作为元素节点的子代的节点</p>
</li>
<li>
<p>firstElementChild，lastElementChild — 第一个和最后一个子元素。</p>
</li>
<li>
<p>previousElementSibling，nextElementSibling — 兄弟元素。</p>
</li>
<li>
<p>parentElement — 父元素。</p>
</li>
</ul>
<p>搜索DOM最常用的方法 document.querySelectorAll()和querySelector()</p>
<p>element.matches()方法 匹配给定的css选择器 返回true or false</p>
<p>element.closest()方法是matches方法的精简版，它只搜索它自己和它的祖先，返回值为第一个找到的元素</p>
<p><strong>querySelector类型的方法和getElementsBy*类型的方法的区别</strong></p>
<p>所有的 &quot;getElementsBy*&quot; 方法都会返回一个 实时的（live） 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。(getElementById 返回一个元素，所有没有实时集合这一说法)</p>
<p>相反，querySelector类型返回的内容固定不变。</p>
<h2 id="dom集合类数组的可迭代对象">DOM集合(类数组的可迭代对象)</h2>
<ol>
<li>
<p>可以用for of 迭代</p>
</li>
<li>
<p>有length属性和下标但没有数组方法</p>
</li>
</ol>
<h2 id="dom的继承关系">DOM的继承关系</h2>
<figure data-type="image" tabindex="1"><img src="https://null-go.github.io/post-images/1616076970054.png" alt="" loading="lazy"></figure>
<p><strong>nodeName</strong>属性适用于Node类 tagName适用于Element类。</p>
<p><strong>innerHTML</strong>属性使用于元素，允许将元素中的 HTML 获取为<strong>字符串形式</strong>。文本元素等其他元素用data或nodeValue。</p>
<p><strong>innerHTML</strong> innerHTML+= 会进行完全的重写 innerHTML = &quot;...&quot; + newHTML;这相当于整个HTML还是重新加载了，因此所有的图片和其他资源都将重写加载。</p>
<p><strong>outerHTML</strong> 属性包含了元素的完整 HTML。就像 innerHTML 加上元素本身一样。</p>
<p>outHTML 和 innerHTML最不一样的地方在于， oEle.outHTML = &quot;新的HTML内容&quot;; oEle元素并不会被修改，而是被替换，所有oEle对旧的HTML内容仍然可以引用，只是在DOM树中的位置被替换掉了。</p>
<p><strong>hidden</strong>属性，从技术上来说，hidden 与 style=&quot;display:none&quot; 做的是相同的事。</p>
<h1 id="dom特性attributes和属性properties">DOM特性(attributes)和属性(properties)</h1>
<p>当浏览器解析HTML，它会从中生成DOM对象。对于元素节点，标准的特性(attributes)会变成DOM对象的属性(properties)。故可以通过点 . 运算符获取属性。</p>
<p><strong>特性</strong> : 写在HTML中的内容</p>
<p><strong>属性</strong> : DOM元素对象的属性</p>
<p>所有特性(大小写不敏感)都可以通过使用以下方法进行访问：</p>
<ul>
<li>
<p>elem.hasAttribute(name) — 检查特性是否存在。</p>
</li>
<li>
<p>elem.getAttribute(name) — 获取这个特性值。</p>
</li>
<li>
<p>elem.setAttribute(name, value) — 设置这个特性值。</p>
</li>
<li>
<p>elem.removeAttribute(name) — 移除这个特性。</p>
</li>
<li>
<p>elem.attributes属性读取所有特性</p>
</li>
</ul>
<p>一般来说，一个标准的特性所对应的属性是关联改变的。</p>
<p>例外：  input 的value 属性</p>
<pre><code>// 特性 =&gt; 属性

  input.setAttribute('value', 'text');

  alert(input.value); // text



  // 这个操作无效，属性 =&gt; 特性

  input.value = 'newValue';

  alert(input.getAttribute('value')); // text（没有被更新！）

  //这个“功能”在实际中会派上用场，因为用户行为可能会导致 value 的更改，然后在这些操作之后，如果我们想从 HTML 中恢复“原始”值，那么该值就在特性中。
</code></pre>
<h2 id="非标准的特性"><strong>非标准的特性</strong></h2>
<p>非标准的特性常常用来设置元素的样式</p>
<pre><code>style : 

.order[order-state=&quot;new&quot;] {

    color: green;

}

dom :

&lt;div class=&quot;order&quot; order-state=&quot;new&quot;&gt;

  A new order.

&lt;/div&gt;

//特性值更容易管理。我们可以轻松地更改状态：

  div.setAttribute(&quot;order-state&quot;,new);
</code></pre>
<h1 id="修改文档"><strong>修改文档</strong></h1>
<h2 id="创建方法"><strong>创建方法</strong></h2>
<p>创建元素节点： let div = document.createElement(&quot;div&quot;);</p>
<p>创建文本节点： let textNode = document.createTextNode(&quot;Here is a text node&quot;) (即符号不会进行转义，原原本本的当做字符串显示)</p>
<h2 id="插入方法"><strong>插入方法</strong></h2>
<ul>
<li>
<p>node.append(...nodes or strings) 在node直接子元素最末尾插入</p>
</li>
<li>
<p>node.prepend(...nodes or strings) 在node直接子元素最开头插入</p>
</li>
<li>
<p>node.before(...nodes or strings) 在node前面插入</p>
</li>
<li>
<p>node.after(...nodes or strings) 在node后面插入</p>
</li>
<li>
<p>node.replaceWith(...nodes or strings) 替换node节点</p>
</li>
</ul>
<p>若插入的是字符串，文字将作为<strong>文本</strong>插入(不是HTML代码，即和node.innerHTML = &quot;&quot;不相同，和node.textContent相同)，自动将转化成<strong>文本节点</strong>，&lt;和&gt;等符号将会转义。所以这是一种更安全的方法插入文本，它并不会插入乱七八糟的元素。</p>
<h2 id="eleinsertadjacenthtmltextelementwherecontent">ele.insertAdjacentHTML/Text/Element(where,content)</h2>
<p><strong>where</strong> 参数的取值(4个):</p>
<p>beforebegin 元素之前 afterbegin 元素内部第一个子元素之前</p>
<p>beforeend 元素内部最后一个子元素之后 afterend 元素之后</p>
<p><strong>content</strong> 参数的取值:</p>
<p>对应传入即可，但是Text和Element均已有方法支持了。即append等。</p>
<h2 id="移除方法">移除方法</h2>
<p>node.remove()</p>
<p>注:<strong>如果我们要将一个元素移到另外一个位置，不需要进行remove，所有的插入方法都会从原来的位置删除</strong></p>
<h2 id="克隆节点">克隆节点</h2>
<p>node.cloneNode(true); <strong>深拷贝</strong> 会拷贝其本身(具有特性 attributes)及所有子节点</p>
<p>node.cloneNode(true); <strong>浅拷贝</strong> 只拷贝其本身(具有特性 attributes)</p>
<p>如何删除一个元素内的所有内容</p>
<pre><code>// 错误做法

        function clear(elem) {

            //     1

            for (let i = 0; i &lt; elem.childNodes.length; i++)

                elem.childNodes[i].remove;

            //     2

            for (let item of elem.childNodes)

                item.remove();



        }

        clear(elem); // 清除列表

        //  正确做法

        function clear(elem){

            while(elem.firstChild)

              elem.firstChild.remove();

        }

        clear(elem); // 清除列表
</code></pre>
<p>​</p>
<h1 id="样式和类"><strong>样式和类</strong></h1>
<h2 id="classname和classlist">className和classList</h2>
<p>对className赋值，将会替换整个字符串。</p>
<p>classList是一个特殊的<strong>对象</strong>(可迭代，类数组。classList[0])。它<strong>对应</strong>&quot;class&quot; attribute</p>
<p>classList有下列的方法：</p>
<ul>
<li>
<p>element.add/remove(className) 添加或移除单个类</p>
</li>
<li>
<p>element.toggle(className) 若类存在，则移除类，若类不存在，则添加类。</p>
</li>
<li>
<p>element.contains(className) 检查给定类，返回true/false</p>
</li>
</ul>
<h2 id="元素样式">元素样式</h2>
<p>elem.style 是一类特殊的对象。它<strong>对应</strong>&quot;style&quot; attribute</p>
<p><strong>因为它对应的是style这个attribute特性，所以只有内联的样式它才能够读取到，像是在style标签里定义的height，element.style.height得到是空字符串，通过赋值能改变样式的原因也是内联样式的优先级比较高</strong></p>
<p>对于多词（multi-word）属性，使用驼峰式 camelCase：</p>
<blockquote>
<p>background-color  =&gt; elem.style.backgroundColor</p>
</blockquote>
<p>浏览器前缀- 也用大写字母表示</p>
<pre><code>// 在单个语句中设置多个样式,相当于style attribute 内联样式对象被重置了
elt.style.cssText = &quot;color: blue; border: 1px solid black&quot;;
// 或者,也相当于style attribute 内联样式对象被重置了
elt.setAttribute(&quot;style&quot;, &quot;color:red; border: 1px solid blue;&quot;);

// 设置特定样式，同时保持其他内联样式值不变
elt.style.color = &quot;blue&quot;;
</code></pre>
<p>不能像这样的 div.style=&quot;color: red; width: 100px&quot; 设置完整的属性，因为 CSSStyleDeclaration <strong>应当</strong>是只读的（尽管它在Firefox，Chrome中都能被赋值，是对象本身整体只读，它的属性的值可以改变）。</p>
<pre><code>element.style = {}; 内联样式对象被清空了
getComputedSyle(element,null) = {}; 直接报错了
</code></pre>
<p>对于修改样式，我们可以通过elem.style.*=&quot;&quot; 修改内联样式的方法修改元素样式，如果想获取样式表中的样式，可以通过 getComputedStyle语法。</p>
<p>getComputed(element, [pseudo]) 需要完整的属性值，需要paddingLeft而不是padding</p>
<p>element：</p>
<p>需要被读取样式值的元素。</p>
<p>pseudo：</p>
<p>伪元素（如果需要），例如 ::before。空字符串或无参数则意味着元素本身。由于浏览器的兼容性问题，建议在选择元素本身时传入参数null。</p>
<p>同样返回一个具有样式属性的对象，像ele.style，但现在包括除内联外的其他样式了。</p>
<p><strong>Element.style 和 getComputedStyle(element,pseudo) 返回的均是一个 CSSStyleDeclaration对象</strong></p>
<p>*<em>注意 element.style.<em>和getComputedStyle() 方法返回的对象所拥有的属性均是字符串形式，所以用来参与运算时要特别注意</em></em></p>
<p>getComputedStyle 参与运算时单位要注意，这与下面说的几何属性不一致，几何属性均为<strong>数值</strong>且单位是px</p>
<figure data-type="image" tabindex="2"><img src="https://null-go.github.io/post-images/1616480743854.png" alt="" loading="lazy"></figure>
<h1 id="元素大小和滚动">元素大小和滚动</h1>
<h2 id="元素结构">元素结构</h2>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329102157711.png" alt="image-20210329102157711" style="zoom:80%;" />
<p>这里设置的width本来是300px，但是滚动条占据了一部分内容宽度。(不同的浏览器对滚动条的处理不同)</p>
<p>不包括margin，它本身不是元素的一部分。</p>
<h2 id="几何">几何</h2>
<h2 id="几何属性除-scrolltop和scrollleft外其他均只读">几何属性除 scrollTop和scrollLeft外，其他均只读</h2>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329102509892.png" alt="image-20210329102509892" style="zoom: 80%;" />
<p>这些属性值在技术上来讲是数字，实际上是“像素”，且仅在元素display不为none的情况下有属性值。</p>
<p><strong>offsetParent</strong>：属性，指向最接近的祖先，最近的祖先为下列之一：</p>
<ol>
<li>css定位的元素(position为absolute,relative,fixed)</li>
<li>或<code>&lt;td&gt;</code>,<code>&lt;th&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;body&gt;</code></li>
</ol>
<p><strong>offsetTop和offsetLeft</strong>：提供相对于祖先元素的偏移量，如图</p>
<p>有以下几种情况下，<strong>offsetParent</strong> 的值为 <code>null</code>：</p>
<ol>
<li>对于未显示的元素（<code>display:none</code> 或者不在文档中）。</li>
<li>对于 <code>&lt;body&gt;</code> 与 <code>&lt;html&gt;</code>。</li>
<li>对于带有 <code>position:fixed</code> 的元素。</li>
</ol>
<p><strong>offsetWidth/offsetHeight</strong></p>
<p>包括border及其以内的所有元素大小之和。</p>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329103659938.png" alt="image-20210329103659938" style="zoom:80%;" />
<p><strong>clientWidth/clientHeight</strong></p>
<p>border内(除border)大小，包括了 “content width” 和 “padding”，但不包括滚动条宽度（scrollbar）。</p>
<p>**注：**内联元素和没有CSS样式的元素此属性为0</p>
<p><strong>scrollWidth/scrollHeight</strong></p>
<p>测量方式就像 <code>clientWidth/clientHeight</code>，但它们还包括滚动出（隐藏）的部分：</p>
<p><strong>scrollTop/scrollLeft(可修改)</strong></p>
<p>元素的隐藏、滚动部分的 width/height。</p>
<img src="C:\Users\huangzhehao\AppData\Roaming\Typora\typora-user-images\image-20210329105848961.png" alt="image-20210329105848961" style="zoom:80%;" />
<blockquote>
<p>tips： 当<img>标签没有 width/height时（通过style标签attribute 或 CSS样式），浏览器会假定width和height为0，只到图片加载完成。在第一次加载完成后，浏览器通常会缓存图片，第二次加载时可以得到width/height。要解决第一次加载width/height的问题可以通过添加style标签attribute 或 CSS样式中的width和height解决。</p>
</blockquote>
<h2 id="css属性中width-和-几何属性中clientwidth-的区别">CSS属性中width 和 几何属性中clientWidth 的区别</h2>
<p>即 getComputedStyle(element).width、element.style.width 与 element.clientWidth 的区别</p>
<ol>
<li>CSS属性中的width是以'px'结束的字符串形式，而clientWidth给出的是数值形式</li>
<li>getComputedStyle(element).width对内联元素使用是auto，clientWidth对内联使用是0</li>
<li>CSS属性中的width是根据box-sizing 决定的</li>
<li>CSS属性中的width在不同的浏览器中对scroll的处理可能不一致（一些浏览器从width中抽取部分给scroll），而clientWidth总是不包括滚动条的。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】对象、原型链]]></title>
        <id>https://null-go.github.io/post/js-dui-xiang-yuan-xing-lian/</id>
        <link href="https://null-go.github.io/post/js-dui-xiang-yuan-xing-lian/">
        </link>
        <updated>2021-03-16T08:05:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="属性类型">属性类型</h1>
<h2 id="数据属性">数据属性</h2>
<p>属性标志：<br>
value,writable,configurale,enumerable;<br>
得到属性标识符对象:Object.getOwnPropertyDescriptor(obj,propertyName) 继承的属性不行<br>
修改或创建属性:Object.defineProperty(obj, propertyName, descriptor) 在这种情况在descriptor对象中若有属性没有提供值，会默认为false<br>
同类型的方法还有 getOwnPropertyDescriptors 和 defineProperties<br>
<strong>克隆对象的一个更好的方法</strong><br>
<strong>writable</strong>  属性无法改变 除非Object.defineProperty重新赋值<br>
<strong>configurable</strong> 属性，不可配置的属性不能被删除<br>
不可配置性对 defineProperty 施加了一些限制：</p>
<ul>
<li>不能修改 configurable 标志。</li>
<li>不能修改 enumerable 标志。</li>
<li>不能将 writable: false 修改为 true（反过来则可以）。</li>
<li>不能修改访问者属性的 get/set（但是如果没有可以分配它们）。<br>
<strong>enumerable</strong> 是否可枚举 for in   Object.keys()等等</li>
</ul>
<h2 id="访问器属性">访问器属性</h2>
<p>本质上是获取和设置属性的方法，但是从外部看起来就和普通的属性一样。写在对象中:<br>
get 属性值(){}  set 属性值(){}<br>
访问器标志：<br>
get,set,enumerable,configurable 访问器属性值不能有value,writable</p>
<h1 id="创建对象">创建对象</h1>
<h2 id="工厂模式">工厂模式</h2>
<p>构造函数在new操作符作用后，默认返回的值是那个对象，但是工厂模式在函数内部创建了一个对象，并把这个对象返回了，这样修改了默认的返回值</p>
<h2 id="构造函数模式-检测对象类型-instanceof操作符">构造函数模式 检测对象类型 instanceof操作符</h2>
<h2 id="原型模式">原型模式</h2>
<p>原型<br>
hasOwnProperty in 检测属性是存在于原型对象还是实例  in是无论存在实例还是原型中，均返回true<br>
Object.keys()方法返回实例对象中可枚举的属性<br>
getOwnPropertyNames返回实例对象中的属性，无论其可不可枚举<br>
每创建一个函数，都会同时创建它的prototype对象，这个对象也会自动获得constructor属性<br>
原型的动态性 实例和原型之间的连接仅仅是指针而已<br>
<strong>实例中的【【ProtoType】】指针指向原型而不是指向构造函数</strong></p>
<h2 id="组合使用构造函数模式和原型模式">组合使用构造函数模式和原型模式</h2>
<h2 id="动态原型模式">动态原型模式</h2>
<h2 id="寄生构造函数模式">寄生构造函数模式</h2>
<h2 id="稳妥构造函数模式">稳妥构造函数模式</h2>
<p>稳妥对象，指的是没有公共属性，并且方法中没有引用this<br>
利用闭包访问自己的属性</p>
<h1 id="对象与原型">对象与原型</h1>
<h2 id="对象的隐藏prototype属性-注不要和构造函数的-prototype-属性混淆">对象的隐藏[[Prototype]]属性 (注：不要和构造函数的 prototype 属性混淆)</h2>
<p>在 JavaScript 中，所有的对象都有一个隐藏的 [[Prototype]] 属性，它要么是另一个对象，要么就是 null。它👉的是该对象的原型。</p>
<ul>
<li>我们可以使用 obj.<strong>proto</strong> 访问它（历史遗留下来的 <strong>getter/setter</strong>)<br>
ES6中的访问接口: <em>Object.getProtoypeOf()</em> 和 <em>Object.setPrototype</em> 来get/set</li>
<li>如果我们想要读取 obj 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li>
<li>写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</li>
<li>如果我们调用 obj.method()，而且 method 是从原型中获取的，this 仍然会引用 obj。因此，方法始终与当前对象一起使用，即使方法是继承的。</li>
<li>请记住函数也是一个对象，它也有自己的原型。<pre><code>function f (){
}
console.log(f.prototype === Function.prototype); //flase
console.log(f.__proto__ === Function.prototype); //true
console.log(Function.__proto__ === Function.prototype); //true
</code></pre>
</li>
</ul>
<h2 id="构造函数">构造函数</h2>
<ul>
<li>每个函数都有 &quot;prototype&quot; 属性，即使我们没有提供它。默认的 &quot;prototype&quot; 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。</li>
<li>如果我们将整个默认 prototype 替换掉，那么其中就不会有 &quot;constructor&quot; 了</li>
<li>F.prototype 属性（不要把它与 [[Prototype]] 弄混了）在 new F 被调用时为新对象的 [*[Prototype]] 赋值。</li>
<li>F.prototype 的值要么是一个对象，要么就是 null：其他值都不起作用。</li>
<li>&quot;prototype&quot; 属性仅在设置了一个构造函数（constructor function），并通过 new 调用时，才具有这种特殊的影响。</li>
</ul>
<p>今天在看原型内容的时候遇到了一个问题：</p>
<pre><code>let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// 这只仓鼠找到了食物
speedy.eat(&quot;apple&quot;);
alert( speedy.stomach ); // apple

// 这只仓鼠也找到了食物，为什么？请修复它。
alert( lazy.stomach ); // apple
</code></pre>
<pre><code>let hamster = {
  stomach: [],

  eat(food) {
    // 分配给 this.stomach 而不是 this.stomach.push
    this.stomach = [food];
  }
};

let speedy = {
   __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// 仓鼠 Speedy 找到了食物
speedy.eat(&quot;apple&quot;);
alert( speedy.stomach ); // apple

// 仓鼠 Lazy 的胃是空的
alert( lazy.stomach ); // &lt;nothing&gt;
</code></pre>
<p>当对变量使用赋值操作和变量push操作的不同，让我想到了在小黄书中看到的LHS和RHS 左查询和右查询，右查询和对普通变量的值的查找没什么区别，而右查询是<strong>试图找到变量容器的本身并对其赋值</strong>。<br>
为什么push 和 = 的操作会造成不一样的影响，我思考后觉得 push操作仅仅是RHS，=操作是左赋值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】类数组对象和可迭代对象]]></title>
        <id>https://null-go.github.io/post/js-lei-shu-zu-dui-xiang-he-ke-die-dai-dui-xiang/</id>
        <link href="https://null-go.github.io/post/js-lei-shu-zu-dui-xiang-he-ke-die-dai-dui-xiang/">
        </link>
        <updated>2021-03-15T09:35:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="类数组对象和可迭代对象">类数组对象和可迭代对象</h1>
<h2 id="array-like-objects-类数组对象"><strong><code>array-like objects</code> (类数组对象)</strong></h2>
<p><strong>即类似于数组的对象，有若干索引属性和length属性</strong></p>
<p>一些 JavaScript 对象, 例如 <code>document.getElementsByTagName()</code> 返回的 <code>NodeList</code> 或者函数内部可用的 <code>arguments</code> 对象，他们表面上看起来，外观和行为像数组，但是不共享他们所有的方法。例如 arguments 对象就提供一个 length 属性，但是不实现 <code>forEach()</code>等数组专用方法。</p>
<p>这个时候若想让类数组对象使用数组的方法，可以使用<strong>方法借用</strong>的方式让数组原型上的某个方法调用apply，因为许多数组的方法内部实现均使用this，改变方法内部的this即可以使该方法作用于类数组对象。</p>
<h2 id="iterable-object可迭代对象"><strong><code>Iterable object</code>（可迭代对象）</strong></h2>
<p>要成为可迭代对象，对象必须实现 <strong>@@iterator方法</strong>，这意味着该对象或它的原型链上的对象有@@iterator方法，可通过常量<strong>Symbol.iterator</strong>访问方法。</p>
<p>该方法的返回值为一个对象(<strong>迭代器 iterator</strong>)，该对象必须含有next()方法，next的返回值是一个对象，该对象包含两个属性：</p>
<ul>
<li><code>done（boolean）</code></li>
</ul>
<p>如果迭代器可以产生序列中的下一个值，则为 false。（这等价于没有指定  done 这个属性。）</p>
<ul>
<li><code>value</code></li>
</ul>
<p>迭代器返回的任何 JavaScript 值。done 为 true 时可省略。</p>
<p>可迭代对象：Array，Set，String，Map，DOM集合</p>
<p>for..of..语句专用于可迭代对象，<strong>展开语法</strong> , <strong>解构赋值</strong> 的实现依赖于可迭代对象</p>
<p>当用<code>for(let item of obj)</code>时，尝试调用 <code>obj</code>的<code>[Symbol.iterator]</code>方法返回一个迭代器，再调用<code>迭代器next()</code>方法，最后</p>
<p><code>item</code>为<code>next</code>方法返回的对象的<code>value</code>值。</p>
<h2 id="将类数组对象和可迭代对象转化为真正的数组"><strong>将类数组对象和可迭代对象转化为真正的数组</strong></h2>
<p><strong>使用全局方法 Array.from()</strong>   Array.from(arrayLike[, mapFn[, thisArg]]);</p>
<p><code>arrayLike</code>：想要转换成数组的类数组对象或可迭代对象。</p>
<p><code>mapFn</code>：可选， 如果指定了该参数，新数组中的每个元素会执行该回调函数。即map(映射)函数</p>
<p><code>thisArg</code>：可选，指定回调函数的this值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JS】this 指向]]></title>
        <id>https://null-go.github.io/post/js-this-zhi-xiang/</id>
        <link href="https://null-go.github.io/post/js-this-zhi-xiang/">
        </link>
        <updated>2021-03-13T07:59:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="this的指向问题的几个重点">this的指向问题的几个重点</h2>
<ol>
<li>this可以用于任何函数或者方法。</li>
<li>this是不受限制的。</li>
<li>在 JavaScript 中，this 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于函数声明的位置，而是取决于在“点符号前”的是什么对象。</li>
</ol>
<h1 id="作为对象的方法调用this指向本对象且this靠近最后一个对象">作为对象的方法调用，this指向本对象，且this靠近最后一个对象</h1>
<h1 id="对象原型上的方法中的this依然会指向new构造出来的对象实例上一条的拓展">对象原型上的方法中的this依然会指向new构造出来的对象实例(上一条的拓展)</h1>
<h1 id="在对象的构造函数中使用new方法this指向构造的那个对象">在对象的构造函数中，使用new方法，this指向构造的那个对象</h1>
<h1 id="作为普通的函数调用严格模式在this指向undefined非严格模式下指向全局函数浏览器window">作为普通的函数调用，严格模式在this指向undefined，非严格模式下指向全局函数(浏览器window)</h1>
<h1 id="匿名函数this指向window若在绑定事件处理函数时传递匿名函数作为参数则作为参数的匿名函数中的this指向绑定事件处理函数的元素">匿名函数this指向window，若在绑定事件处理函数时传递匿名函数作为参数，则作为参数的匿名函数中的this指向绑定事件处理函数的元素</h1>
<h1 id="箭头函数的this值来自闭合词法上下文上一层执行上下文的值也就是说箭头函数的this在函数创建时就已经绑定好了这与其他函数情况不同this传递给call-bind-或者apply来调用箭头函数它将被忽略">箭头函数的this值来自闭合词法上下文(上一层执行上下文)的值(也就是说，箭头函数的this在函数创建时就已经绑定好了，这与其他函数情况不同，this传递给call、bind、或者apply来调用箭头函数，它将被忽略。)</h1>
<p><strong>修改this指向</strong><br>
<em>apply/call</em>方法 立即执行 func.call(context, arg1, arg2, ...) func.apply(context, args)类数组对象<br>
apply 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。<br>
<em>bind</em> 复制一份新的函数<br>
bind(context,arg1,arg2,..) 除了绑定上下文，还能预定给函数传入参数，在复制后的函数调用时自动传入，同时调用时传入的参数在预定参数之后传入。（这种方式称为<em>偏函数</em>）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【ES6】语法简学]]></title>
        <id>https://null-go.github.io/post/es6-yu-fa-jie-xi/</id>
        <link href="https://null-go.github.io/post/es6-yu-fa-jie-xi/">
        </link>
        <updated>2021-03-12T02:41:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="let-和-const命令">let 和 const命令</h1>
<ol>
<li>块级作用域和函数声明<br>
ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br>
但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，不会报错。<br>
ES6中明确规定，函数在块级作用域中声明类似于let，在块级作用域外不可见。<br>
但是如果<strong>浏览器</strong>都明确遵守ES6中的函数声明，那必然会对老代码产生巨大的影响，所以<strong>浏览器</strong>(其他环境遵循ES6)有以下三条规则:</li>
</ol>
<blockquote>
<p>允许在块级作用域内声明函数。<br>
函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>
同时，函数声明还会提升到所在的块级作用域的头部。</p>
</blockquote>
<ol start="2">
<li>
<p>const<br>
const声明的同时必须初始化，仅在块级作用域中有效，存在暂时性死区，不可重复声明。<br>
const表示值不能发生改变，const声明的变量若等于简单类型数据，指变量的值不能发生改变，若等于引用类型数据，指变量指向的地址不能改变，但地址指向的数据结构可以改变。</p>
</li>
<li>
<p>顶层对象的属性<br>
顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。(var 和 function定义的全局变量会成为顶层对象的属性)。顶层对象是一个有实体含义的对象，也是不合适的。<br>
ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
</li>
<li>
<p>globleThis对象<br>
JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。</p>
</li>
</ol>
<h1 id="变量解构赋值">变量解构赋值</h1>
<h1 id="class语法">Class语法</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Vue】解决动态绑定本地图片的问题]]></title>
        <id>https://null-go.github.io/post/vue-jie-jue-dong-tai-bang-ding-ben-di-tu-pian-de-wen-ti/</id>
        <link href="https://null-go.github.io/post/vue-jie-jue-dong-tai-bang-ding-ben-di-tu-pian-de-wen-ti/">
        </link>
        <updated>2021-03-09T14:19:41.000Z</updated>
        <content type="html"><![CDATA[<p>一开始出现这个问题是源自于Vue组件化，将一个复用的模块做出组件后，要求向子组件传递一个src引用一张<strong>本地</strong>的图片，传递过去src是一个变量，在img标签中单向绑定<strong>v-bind:src=</strong>。发现出错了，上网查找资料后发现是webpack的问题，webpack会将assets文件夹处理解析为<strong>模块依赖</strong>，具体原因不知道，因为对webpack还不了解😥😢。<br>
然后尝试require纯地址路径，还是error找不到module，最终解决，解决方法：<strong>require(path) ,path</strong>至少要有三部分组成, 目录+文件名+后缀，即：</p>
<pre><code>&lt;img :src=&quot;require('../../assets/images/'+pic+'.png')&quot;&gt;
</code></pre>
]]></content>
    </entry>
</feed>